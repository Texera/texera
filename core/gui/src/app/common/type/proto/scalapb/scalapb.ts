// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               v5.28.3
// source: scalapb/scalapb.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { FieldDescriptorProto, FieldOptions as FieldOptions1 } from "../google/protobuf/descriptor";

export const protobufPackage = "scalapb";

export enum MatchType {
  CONTAINS = 0,
  EXACT = 1,
  PRESENCE = 2,
  UNRECOGNIZED = -1,
}

export function matchTypeFromJSON(object: any): MatchType {
  switch (object) {
    case 0:
    case "CONTAINS":
      return MatchType.CONTAINS;
    case 1:
    case "EXACT":
      return MatchType.EXACT;
    case 2:
    case "PRESENCE":
      return MatchType.PRESENCE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return MatchType.UNRECOGNIZED;
  }
}

export function matchTypeToJSON(object: MatchType): string {
  switch (object) {
    case MatchType.CONTAINS:
      return "CONTAINS";
    case MatchType.EXACT:
      return "EXACT";
    case MatchType.PRESENCE:
      return "PRESENCE";
    case MatchType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface ScalaPbOptions {
  /** If set then it overrides the java_package and package. */
  packageName?: string | undefined;
  /**
   * If true, the compiler does not append the proto base file name
   * into the generated package name. If false (the default), the
   * generated scala package name is the package_name.basename where
   * basename is the proto file name without the .proto extension.
   */
  flatPackage?: boolean | undefined;
  /**
   * Adds the following imports at the top of the file (this is meant
   * to provide implicit TypeMappers)
   */
  import: string[];
  /**
   * Text to add to the generated scala file.  This can be used only
   * when single_file is true.
   */
  preamble: string[];
  /**
   * If true, all messages and enums (but not services) will be written
   * to a single Scala file.
   */
  singleFile?: boolean | undefined;
  /**
   * By default, wrappers defined at
   * https://github.com/google/protobuf/blob/master/src/google/protobuf/wrappers.proto,
   * are mapped to an Option[T] where T is a primitive type. When this field
   * is set to true, we do not perform this transformation.
   */
  noPrimitiveWrappers?: boolean | undefined;
  /**
   * DEPRECATED. In ScalaPB <= 0.5.47, it was necessary to explicitly enable
   * primitive_wrappers. This field remains here for backwards compatibility,
   * but it has no effect on generated code. It is an error to set both
   * `primitive_wrappers` and `no_primitive_wrappers`.
   */
  primitiveWrappers?: boolean | undefined;
  /**
   * Scala type to be used for repeated fields. If unspecified,
   * `scala.collection.Seq` will be used.
   */
  collectionType?: string | undefined;
  /**
   * If set to true, all generated messages in this file will preserve unknown
   * fields.
   */
  preserveUnknownFields?: boolean | undefined;
  /**
   * If defined, sets the name of the file-level object that would be generated. This
   * object extends `GeneratedFileObject` and contains descriptors, and list of message
   * and enum companions.
   */
  objectName?: string | undefined;
  /** Experimental: scope to apply the given options. */
  scope?: ScalaPbOptions_OptionsScope | undefined;
  /** If true, lenses will be generated. */
  lenses?: boolean | undefined;
  /**
   * If true, then source-code info information will be included in the
   * generated code - normally the source code info is cleared out to reduce
   * code size.  The source code info is useful for extracting source code
   * location from the descriptors as well as comments.
   */
  retainSourceCodeInfo?: boolean | undefined;
  /**
   * Scala type to be used for maps. If unspecified,
   * `scala.collection.immutable.Map` will be used.
   */
  mapType?: string | undefined;
  /** If true, no default values will be generated in message constructors. */
  noDefaultValuesInConstructor?: boolean | undefined;
  enumValueNaming?: ScalaPbOptions_EnumValueNaming | undefined;
  /**
   * Indicate if prefix (enum name + optional underscore) should be removed in scala code
   * Strip is applied before enum value naming changes.
   */
  enumStripPrefix?: boolean | undefined;
  /** Scala type to use for bytes fields. */
  bytesType?: string | undefined;
  /** Enable java conversions for this file. */
  javaConversions?: boolean | undefined;
  /** List of message options to apply to some messages. */
  auxMessageOptions: ScalaPbOptions_AuxMessageOptions[];
  /** List of message options to apply to some fields. */
  auxFieldOptions: ScalaPbOptions_AuxFieldOptions[];
  /** List of message options to apply to some enums. */
  auxEnumOptions: ScalaPbOptions_AuxEnumOptions[];
  /** List of enum value options to apply to some enum values. */
  auxEnumValueOptions: ScalaPbOptions_AuxEnumValueOptions[];
  /** List of preprocessors to apply. */
  preprocessors: string[];
  fieldTransformations: FieldTransformation[];
  /**
   * Ignores all transformations for this file. This is meant to allow specific files to
   * opt out from transformations inherited through package-scoped options.
   */
  ignoreAllTransformations?: boolean | undefined;
  /** If true, getters will be generated. */
  getters?: boolean | undefined;
  /**
   * For use in tests only. Inhibit Java conversions even when when generator parameters
   * request for it.
   */
  testOnlyNoJavaConversions?: boolean | undefined;
}

/** Whether to apply the options only to this file, or for the entire package (and its subpackages) */
export enum ScalaPbOptions_OptionsScope {
  /** FILE - Apply the options for this file only (default) */
  FILE = 0,
  /** PACKAGE - Apply the options for the entire package and its subpackages. */
  PACKAGE = 1,
  UNRECOGNIZED = -1,
}

export function scalaPbOptions_OptionsScopeFromJSON(object: any): ScalaPbOptions_OptionsScope {
  switch (object) {
    case 0:
    case "FILE":
      return ScalaPbOptions_OptionsScope.FILE;
    case 1:
    case "PACKAGE":
      return ScalaPbOptions_OptionsScope.PACKAGE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ScalaPbOptions_OptionsScope.UNRECOGNIZED;
  }
}

export function scalaPbOptions_OptionsScopeToJSON(object: ScalaPbOptions_OptionsScope): string {
  switch (object) {
    case ScalaPbOptions_OptionsScope.FILE:
      return "FILE";
    case ScalaPbOptions_OptionsScope.PACKAGE:
      return "PACKAGE";
    case ScalaPbOptions_OptionsScope.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** Naming convention for generated enum values */
export enum ScalaPbOptions_EnumValueNaming {
  /** AS_IN_PROTO - Enum value names in Scala use the same name as in the proto */
  AS_IN_PROTO = 0,
  /** CAMEL_CASE - Convert enum values to CamelCase in Scala. */
  CAMEL_CASE = 1,
  UNRECOGNIZED = -1,
}

export function scalaPbOptions_EnumValueNamingFromJSON(object: any): ScalaPbOptions_EnumValueNaming {
  switch (object) {
    case 0:
    case "AS_IN_PROTO":
      return ScalaPbOptions_EnumValueNaming.AS_IN_PROTO;
    case 1:
    case "CAMEL_CASE":
      return ScalaPbOptions_EnumValueNaming.CAMEL_CASE;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ScalaPbOptions_EnumValueNaming.UNRECOGNIZED;
  }
}

export function scalaPbOptions_EnumValueNamingToJSON(object: ScalaPbOptions_EnumValueNaming): string {
  switch (object) {
    case ScalaPbOptions_EnumValueNaming.AS_IN_PROTO:
      return "AS_IN_PROTO";
    case ScalaPbOptions_EnumValueNaming.CAMEL_CASE:
      return "CAMEL_CASE";
    case ScalaPbOptions_EnumValueNaming.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/**
 * AuxMessageOptions enables you to set message-level options through package-scoped options.
 * This is useful when you can't add a dependency on scalapb.proto from the proto file that
 * defines the message.
 */
export interface ScalaPbOptions_AuxMessageOptions {
  /** The fully-qualified name of the message in the proto name space. */
  target?: string | undefined;
  /**
   * Options to apply to the message. If there are any options defined on the target message
   * they take precedence over the options.
   */
  options?: MessageOptions | undefined;
}

/**
 * AuxFieldOptions enables you to set field-level options through package-scoped options.
 * This is useful when you can't add a dependency on scalapb.proto from the proto file that
 * defines the field.
 */
export interface ScalaPbOptions_AuxFieldOptions {
  /** The fully-qualified name of the field in the proto name space. */
  target?: string | undefined;
  /**
   * Options to apply to the field. If there are any options defined on the target message
   * they take precedence over the options.
   */
  options?: FieldOptions | undefined;
}

/**
 * AuxEnumOptions enables you to set enum-level options through package-scoped options.
 * This is useful when you can't add a dependency on scalapb.proto from the proto file that
 * defines the enum.
 */
export interface ScalaPbOptions_AuxEnumOptions {
  /** The fully-qualified name of the enum in the proto name space. */
  target?: string | undefined;
  /**
   * Options to apply to the enum. If there are any options defined on the target enum
   * they take precedence over the options.
   */
  options?: EnumOptions | undefined;
}

/**
 * AuxEnumValueOptions enables you to set enum value level options through package-scoped
 * options.  This is useful when you can't add a dependency on scalapb.proto from the proto
 * file that defines the enum.
 */
export interface ScalaPbOptions_AuxEnumValueOptions {
  /** The fully-qualified name of the enum value in the proto name space. */
  target?: string | undefined;
  /**
   * Options to apply to the enum value. If there are any options defined on
   * the target enum value they take precedence over the options.
   */
  options?: EnumValueOptions | undefined;
}

export interface MessageOptions {
  /** Additional classes and traits to mix in to the case class. */
  extends: string[];
  /** Additional classes and traits to mix in to the companion object. */
  companionExtends: string[];
  /** Custom annotations to add to the generated case class. */
  annotations: string[];
  /**
   * All instances of this message will be converted to this type. An implicit TypeMapper
   * must be present.
   */
  type?: string | undefined;
  /** Custom annotations to add to the companion object of the generated class. */
  companionAnnotations: string[];
  /** Additional classes and traits to mix in to generated sealed_oneof base trait. */
  sealedOneofExtends: string[];
  /**
   * If true, when this message is used as an optional field, do not wrap it in an `Option`.
   * This is equivalent of setting `(field).no_box` to true on each field with the message type.
   */
  noBox?: boolean | undefined;
  /** Custom annotations to add to the generated `unknownFields` case class field. */
  unknownFieldsAnnotations: string[];
}

/**
 * Represents a custom Collection type in Scala. This allows ScalaPB to integrate with
 * collection types that are different enough from the ones in the standard library.
 */
export interface Collection {
  /** Type of the collection */
  type?: string | undefined;
  /**
   * Set to true if this collection type is not allowed to be empty, for example
   * cats.data.NonEmptyList.  When true, ScalaPB will not generate `clearX` for the repeated
   * field and not provide a default argument in the constructor.
   */
  nonEmpty?: boolean | undefined;
  /**
   * An Adapter is a Scala object available at runtime that provides certain static methods
   * that can operate on this collection type.
   */
  adapter?: string | undefined;
}

export interface FieldOptions {
  type?: string | undefined;
  scalaName?: string | undefined;
  /**
   * Can be specified only if this field is repeated. If unspecified,
   * it falls back to the file option named `collection_type`, which defaults
   * to `scala.collection.Seq`.
   */
  collectionType?: string | undefined;
  collection?: Collection | undefined;
  /**
   * If the field is a map, you can specify custom Scala types for the key
   * or value.
   */
  keyType?: string | undefined;
  valueType?: string | undefined;
  /** Custom annotations to add to the field. */
  annotations: string[];
  /**
   * Can be specified only if this field is a map. If unspecified,
   * it falls back to the file option named `map_type` which defaults to
   * `scala.collection.immutable.Map`
   */
  mapType?: string | undefined;
  /** Do not box this value in Option[T]. If set, this overrides MessageOptions.no_box */
  noBox?: boolean | undefined;
  /**
   * Like no_box it does not box a value in Option[T], but also fails parsing when a value
   * is not provided. This enables to emulate required fields in proto3.
   */
  required?: boolean | undefined;
}

export interface EnumOptions {
  /** Additional classes and traits to mix in to the base trait */
  extends: string[];
  /** Additional classes and traits to mix in to the companion object. */
  companionExtends: string[];
  /**
   * All instances of this enum will be converted to this type. An implicit TypeMapper
   * must be present.
   */
  type?: string | undefined;
  /** Custom annotations to add to the generated enum's base class. */
  baseAnnotations: string[];
  /** Custom annotations to add to the generated trait. */
  recognizedAnnotations: string[];
  /** Custom annotations to add to the generated Unrecognized case class. */
  unrecognizedAnnotations: string[];
}

export interface EnumValueOptions {
  /** Additional classes and traits to mix in to an individual enum value. */
  extends: string[];
  /** Name in Scala to use for this enum value. */
  scalaName?: string | undefined;
  /** Custom annotations to add to the generated case object for this enum value. */
  annotations: string[];
}

export interface OneofOptions {
  /** Additional traits to mix in to a oneof. */
  extends: string[];
  /** Name in Scala to use for this oneof field. */
  scalaName?: string | undefined;
}

export interface FieldTransformation {
  when?: FieldDescriptorProto | undefined;
  matchType?: MatchType | undefined;
  set?: FieldOptions1 | undefined;
}

export interface PreprocessorOutput {
  optionsByFile: { [key: string]: ScalaPbOptions };
}

export interface PreprocessorOutput_OptionsByFileEntry {
  key: string;
  value: ScalaPbOptions | undefined;
}

function createBaseScalaPbOptions(): ScalaPbOptions {
  return {
    packageName: "",
    flatPackage: false,
    import: [],
    preamble: [],
    singleFile: false,
    noPrimitiveWrappers: false,
    primitiveWrappers: false,
    collectionType: "",
    preserveUnknownFields: true,
    objectName: "",
    scope: 0,
    lenses: true,
    retainSourceCodeInfo: false,
    mapType: "",
    noDefaultValuesInConstructor: false,
    enumValueNaming: 0,
    enumStripPrefix: false,
    bytesType: "",
    javaConversions: false,
    auxMessageOptions: [],
    auxFieldOptions: [],
    auxEnumOptions: [],
    auxEnumValueOptions: [],
    preprocessors: [],
    fieldTransformations: [],
    ignoreAllTransformations: false,
    getters: true,
    testOnlyNoJavaConversions: false,
  };
}

export const ScalaPbOptions: MessageFns<ScalaPbOptions> = {
  encode(message: ScalaPbOptions, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.packageName !== undefined && message.packageName !== "") {
      writer.uint32(10).string(message.packageName);
    }
    if (message.flatPackage !== undefined && message.flatPackage !== false) {
      writer.uint32(16).bool(message.flatPackage);
    }
    for (const v of message.import) {
      writer.uint32(26).string(v!);
    }
    for (const v of message.preamble) {
      writer.uint32(34).string(v!);
    }
    if (message.singleFile !== undefined && message.singleFile !== false) {
      writer.uint32(40).bool(message.singleFile);
    }
    if (message.noPrimitiveWrappers !== undefined && message.noPrimitiveWrappers !== false) {
      writer.uint32(56).bool(message.noPrimitiveWrappers);
    }
    if (message.primitiveWrappers !== undefined && message.primitiveWrappers !== false) {
      writer.uint32(48).bool(message.primitiveWrappers);
    }
    if (message.collectionType !== undefined && message.collectionType !== "") {
      writer.uint32(66).string(message.collectionType);
    }
    if (message.preserveUnknownFields !== undefined && message.preserveUnknownFields !== true) {
      writer.uint32(72).bool(message.preserveUnknownFields);
    }
    if (message.objectName !== undefined && message.objectName !== "") {
      writer.uint32(82).string(message.objectName);
    }
    if (message.scope !== undefined && message.scope !== 0) {
      writer.uint32(88).int32(message.scope);
    }
    if (message.lenses !== undefined && message.lenses !== true) {
      writer.uint32(96).bool(message.lenses);
    }
    if (message.retainSourceCodeInfo !== undefined && message.retainSourceCodeInfo !== false) {
      writer.uint32(104).bool(message.retainSourceCodeInfo);
    }
    if (message.mapType !== undefined && message.mapType !== "") {
      writer.uint32(114).string(message.mapType);
    }
    if (message.noDefaultValuesInConstructor !== undefined && message.noDefaultValuesInConstructor !== false) {
      writer.uint32(120).bool(message.noDefaultValuesInConstructor);
    }
    if (message.enumValueNaming !== undefined && message.enumValueNaming !== 0) {
      writer.uint32(128).int32(message.enumValueNaming);
    }
    if (message.enumStripPrefix !== undefined && message.enumStripPrefix !== false) {
      writer.uint32(136).bool(message.enumStripPrefix);
    }
    if (message.bytesType !== undefined && message.bytesType !== "") {
      writer.uint32(170).string(message.bytesType);
    }
    if (message.javaConversions !== undefined && message.javaConversions !== false) {
      writer.uint32(184).bool(message.javaConversions);
    }
    for (const v of message.auxMessageOptions) {
      ScalaPbOptions_AuxMessageOptions.encode(v!, writer.uint32(146).fork()).join();
    }
    for (const v of message.auxFieldOptions) {
      ScalaPbOptions_AuxFieldOptions.encode(v!, writer.uint32(154).fork()).join();
    }
    for (const v of message.auxEnumOptions) {
      ScalaPbOptions_AuxEnumOptions.encode(v!, writer.uint32(162).fork()).join();
    }
    for (const v of message.auxEnumValueOptions) {
      ScalaPbOptions_AuxEnumValueOptions.encode(v!, writer.uint32(178).fork()).join();
    }
    for (const v of message.preprocessors) {
      writer.uint32(194).string(v!);
    }
    for (const v of message.fieldTransformations) {
      FieldTransformation.encode(v!, writer.uint32(202).fork()).join();
    }
    if (message.ignoreAllTransformations !== undefined && message.ignoreAllTransformations !== false) {
      writer.uint32(208).bool(message.ignoreAllTransformations);
    }
    if (message.getters !== undefined && message.getters !== true) {
      writer.uint32(216).bool(message.getters);
    }
    if (message.testOnlyNoJavaConversions !== undefined && message.testOnlyNoJavaConversions !== false) {
      writer.uint32(7992).bool(message.testOnlyNoJavaConversions);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ScalaPbOptions {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseScalaPbOptions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.packageName = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.flatPackage = reader.bool();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.import.push(reader.string());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.preamble.push(reader.string());
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.singleFile = reader.bool();
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.noPrimitiveWrappers = reader.bool();
          continue;
        case 6:
          if (tag !== 48) {
            break;
          }

          message.primitiveWrappers = reader.bool();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.collectionType = reader.string();
          continue;
        case 9:
          if (tag !== 72) {
            break;
          }

          message.preserveUnknownFields = reader.bool();
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.objectName = reader.string();
          continue;
        case 11:
          if (tag !== 88) {
            break;
          }

          message.scope = reader.int32() as any;
          continue;
        case 12:
          if (tag !== 96) {
            break;
          }

          message.lenses = reader.bool();
          continue;
        case 13:
          if (tag !== 104) {
            break;
          }

          message.retainSourceCodeInfo = reader.bool();
          continue;
        case 14:
          if (tag !== 114) {
            break;
          }

          message.mapType = reader.string();
          continue;
        case 15:
          if (tag !== 120) {
            break;
          }

          message.noDefaultValuesInConstructor = reader.bool();
          continue;
        case 16:
          if (tag !== 128) {
            break;
          }

          message.enumValueNaming = reader.int32() as any;
          continue;
        case 17:
          if (tag !== 136) {
            break;
          }

          message.enumStripPrefix = reader.bool();
          continue;
        case 21:
          if (tag !== 170) {
            break;
          }

          message.bytesType = reader.string();
          continue;
        case 23:
          if (tag !== 184) {
            break;
          }

          message.javaConversions = reader.bool();
          continue;
        case 18:
          if (tag !== 146) {
            break;
          }

          message.auxMessageOptions.push(ScalaPbOptions_AuxMessageOptions.decode(reader, reader.uint32()));
          continue;
        case 19:
          if (tag !== 154) {
            break;
          }

          message.auxFieldOptions.push(ScalaPbOptions_AuxFieldOptions.decode(reader, reader.uint32()));
          continue;
        case 20:
          if (tag !== 162) {
            break;
          }

          message.auxEnumOptions.push(ScalaPbOptions_AuxEnumOptions.decode(reader, reader.uint32()));
          continue;
        case 22:
          if (tag !== 178) {
            break;
          }

          message.auxEnumValueOptions.push(ScalaPbOptions_AuxEnumValueOptions.decode(reader, reader.uint32()));
          continue;
        case 24:
          if (tag !== 194) {
            break;
          }

          message.preprocessors.push(reader.string());
          continue;
        case 25:
          if (tag !== 202) {
            break;
          }

          message.fieldTransformations.push(FieldTransformation.decode(reader, reader.uint32()));
          continue;
        case 26:
          if (tag !== 208) {
            break;
          }

          message.ignoreAllTransformations = reader.bool();
          continue;
        case 27:
          if (tag !== 216) {
            break;
          }

          message.getters = reader.bool();
          continue;
        case 999:
          if (tag !== 7992) {
            break;
          }

          message.testOnlyNoJavaConversions = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ScalaPbOptions {
    return {
      packageName: isSet(object.packageName) ? globalThis.String(object.packageName) : "",
      flatPackage: isSet(object.flatPackage) ? globalThis.Boolean(object.flatPackage) : false,
      import: globalThis.Array.isArray(object?.import) ? object.import.map((e: any) => globalThis.String(e)) : [],
      preamble: globalThis.Array.isArray(object?.preamble) ? object.preamble.map((e: any) => globalThis.String(e)) : [],
      singleFile: isSet(object.singleFile) ? globalThis.Boolean(object.singleFile) : false,
      noPrimitiveWrappers: isSet(object.noPrimitiveWrappers) ? globalThis.Boolean(object.noPrimitiveWrappers) : false,
      primitiveWrappers: isSet(object.primitiveWrappers) ? globalThis.Boolean(object.primitiveWrappers) : false,
      collectionType: isSet(object.collectionType) ? globalThis.String(object.collectionType) : "",
      preserveUnknownFields: isSet(object.preserveUnknownFields)
        ? globalThis.Boolean(object.preserveUnknownFields)
        : true,
      objectName: isSet(object.objectName) ? globalThis.String(object.objectName) : "",
      scope: isSet(object.scope) ? scalaPbOptions_OptionsScopeFromJSON(object.scope) : 0,
      lenses: isSet(object.lenses) ? globalThis.Boolean(object.lenses) : true,
      retainSourceCodeInfo: isSet(object.retainSourceCodeInfo)
        ? globalThis.Boolean(object.retainSourceCodeInfo)
        : false,
      mapType: isSet(object.mapType) ? globalThis.String(object.mapType) : "",
      noDefaultValuesInConstructor: isSet(object.noDefaultValuesInConstructor)
        ? globalThis.Boolean(object.noDefaultValuesInConstructor)
        : false,
      enumValueNaming: isSet(object.enumValueNaming)
        ? scalaPbOptions_EnumValueNamingFromJSON(object.enumValueNaming)
        : 0,
      enumStripPrefix: isSet(object.enumStripPrefix) ? globalThis.Boolean(object.enumStripPrefix) : false,
      bytesType: isSet(object.bytesType) ? globalThis.String(object.bytesType) : "",
      javaConversions: isSet(object.javaConversions) ? globalThis.Boolean(object.javaConversions) : false,
      auxMessageOptions: globalThis.Array.isArray(object?.auxMessageOptions)
        ? object.auxMessageOptions.map((e: any) => ScalaPbOptions_AuxMessageOptions.fromJSON(e))
        : [],
      auxFieldOptions: globalThis.Array.isArray(object?.auxFieldOptions)
        ? object.auxFieldOptions.map((e: any) => ScalaPbOptions_AuxFieldOptions.fromJSON(e))
        : [],
      auxEnumOptions: globalThis.Array.isArray(object?.auxEnumOptions)
        ? object.auxEnumOptions.map((e: any) => ScalaPbOptions_AuxEnumOptions.fromJSON(e))
        : [],
      auxEnumValueOptions: globalThis.Array.isArray(object?.auxEnumValueOptions)
        ? object.auxEnumValueOptions.map((e: any) => ScalaPbOptions_AuxEnumValueOptions.fromJSON(e))
        : [],
      preprocessors: globalThis.Array.isArray(object?.preprocessors)
        ? object.preprocessors.map((e: any) => globalThis.String(e))
        : [],
      fieldTransformations: globalThis.Array.isArray(object?.fieldTransformations)
        ? object.fieldTransformations.map((e: any) => FieldTransformation.fromJSON(e))
        : [],
      ignoreAllTransformations: isSet(object.ignoreAllTransformations)
        ? globalThis.Boolean(object.ignoreAllTransformations)
        : false,
      getters: isSet(object.getters) ? globalThis.Boolean(object.getters) : true,
      testOnlyNoJavaConversions: isSet(object.testOnlyNoJavaConversions)
        ? globalThis.Boolean(object.testOnlyNoJavaConversions)
        : false,
    };
  },

  toJSON(message: ScalaPbOptions): unknown {
    const obj: any = {};
    if (message.packageName !== undefined && message.packageName !== "") {
      obj.packageName = message.packageName;
    }
    if (message.flatPackage !== undefined && message.flatPackage !== false) {
      obj.flatPackage = message.flatPackage;
    }
    if (message.import?.length) {
      obj.import = message.import;
    }
    if (message.preamble?.length) {
      obj.preamble = message.preamble;
    }
    if (message.singleFile !== undefined && message.singleFile !== false) {
      obj.singleFile = message.singleFile;
    }
    if (message.noPrimitiveWrappers !== undefined && message.noPrimitiveWrappers !== false) {
      obj.noPrimitiveWrappers = message.noPrimitiveWrappers;
    }
    if (message.primitiveWrappers !== undefined && message.primitiveWrappers !== false) {
      obj.primitiveWrappers = message.primitiveWrappers;
    }
    if (message.collectionType !== undefined && message.collectionType !== "") {
      obj.collectionType = message.collectionType;
    }
    if (message.preserveUnknownFields !== undefined && message.preserveUnknownFields !== true) {
      obj.preserveUnknownFields = message.preserveUnknownFields;
    }
    if (message.objectName !== undefined && message.objectName !== "") {
      obj.objectName = message.objectName;
    }
    if (message.scope !== undefined && message.scope !== 0) {
      obj.scope = scalaPbOptions_OptionsScopeToJSON(message.scope);
    }
    if (message.lenses !== undefined && message.lenses !== true) {
      obj.lenses = message.lenses;
    }
    if (message.retainSourceCodeInfo !== undefined && message.retainSourceCodeInfo !== false) {
      obj.retainSourceCodeInfo = message.retainSourceCodeInfo;
    }
    if (message.mapType !== undefined && message.mapType !== "") {
      obj.mapType = message.mapType;
    }
    if (message.noDefaultValuesInConstructor !== undefined && message.noDefaultValuesInConstructor !== false) {
      obj.noDefaultValuesInConstructor = message.noDefaultValuesInConstructor;
    }
    if (message.enumValueNaming !== undefined && message.enumValueNaming !== 0) {
      obj.enumValueNaming = scalaPbOptions_EnumValueNamingToJSON(message.enumValueNaming);
    }
    if (message.enumStripPrefix !== undefined && message.enumStripPrefix !== false) {
      obj.enumStripPrefix = message.enumStripPrefix;
    }
    if (message.bytesType !== undefined && message.bytesType !== "") {
      obj.bytesType = message.bytesType;
    }
    if (message.javaConversions !== undefined && message.javaConversions !== false) {
      obj.javaConversions = message.javaConversions;
    }
    if (message.auxMessageOptions?.length) {
      obj.auxMessageOptions = message.auxMessageOptions.map(e => ScalaPbOptions_AuxMessageOptions.toJSON(e));
    }
    if (message.auxFieldOptions?.length) {
      obj.auxFieldOptions = message.auxFieldOptions.map(e => ScalaPbOptions_AuxFieldOptions.toJSON(e));
    }
    if (message.auxEnumOptions?.length) {
      obj.auxEnumOptions = message.auxEnumOptions.map(e => ScalaPbOptions_AuxEnumOptions.toJSON(e));
    }
    if (message.auxEnumValueOptions?.length) {
      obj.auxEnumValueOptions = message.auxEnumValueOptions.map(e => ScalaPbOptions_AuxEnumValueOptions.toJSON(e));
    }
    if (message.preprocessors?.length) {
      obj.preprocessors = message.preprocessors;
    }
    if (message.fieldTransformations?.length) {
      obj.fieldTransformations = message.fieldTransformations.map(e => FieldTransformation.toJSON(e));
    }
    if (message.ignoreAllTransformations !== undefined && message.ignoreAllTransformations !== false) {
      obj.ignoreAllTransformations = message.ignoreAllTransformations;
    }
    if (message.getters !== undefined && message.getters !== true) {
      obj.getters = message.getters;
    }
    if (message.testOnlyNoJavaConversions !== undefined && message.testOnlyNoJavaConversions !== false) {
      obj.testOnlyNoJavaConversions = message.testOnlyNoJavaConversions;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ScalaPbOptions>, I>>(base?: I): ScalaPbOptions {
    return ScalaPbOptions.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ScalaPbOptions>, I>>(object: I): ScalaPbOptions {
    const message = createBaseScalaPbOptions();
    message.packageName = object.packageName ?? "";
    message.flatPackage = object.flatPackage ?? false;
    message.import = object.import?.map(e => e) || [];
    message.preamble = object.preamble?.map(e => e) || [];
    message.singleFile = object.singleFile ?? false;
    message.noPrimitiveWrappers = object.noPrimitiveWrappers ?? false;
    message.primitiveWrappers = object.primitiveWrappers ?? false;
    message.collectionType = object.collectionType ?? "";
    message.preserveUnknownFields = object.preserveUnknownFields ?? true;
    message.objectName = object.objectName ?? "";
    message.scope = object.scope ?? 0;
    message.lenses = object.lenses ?? true;
    message.retainSourceCodeInfo = object.retainSourceCodeInfo ?? false;
    message.mapType = object.mapType ?? "";
    message.noDefaultValuesInConstructor = object.noDefaultValuesInConstructor ?? false;
    message.enumValueNaming = object.enumValueNaming ?? 0;
    message.enumStripPrefix = object.enumStripPrefix ?? false;
    message.bytesType = object.bytesType ?? "";
    message.javaConversions = object.javaConversions ?? false;
    message.auxMessageOptions =
      object.auxMessageOptions?.map(e => ScalaPbOptions_AuxMessageOptions.fromPartial(e)) || [];
    message.auxFieldOptions = object.auxFieldOptions?.map(e => ScalaPbOptions_AuxFieldOptions.fromPartial(e)) || [];
    message.auxEnumOptions = object.auxEnumOptions?.map(e => ScalaPbOptions_AuxEnumOptions.fromPartial(e)) || [];
    message.auxEnumValueOptions =
      object.auxEnumValueOptions?.map(e => ScalaPbOptions_AuxEnumValueOptions.fromPartial(e)) || [];
    message.preprocessors = object.preprocessors?.map(e => e) || [];
    message.fieldTransformations = object.fieldTransformations?.map(e => FieldTransformation.fromPartial(e)) || [];
    message.ignoreAllTransformations = object.ignoreAllTransformations ?? false;
    message.getters = object.getters ?? true;
    message.testOnlyNoJavaConversions = object.testOnlyNoJavaConversions ?? false;
    return message;
  },
};

function createBaseScalaPbOptions_AuxMessageOptions(): ScalaPbOptions_AuxMessageOptions {
  return { target: "", options: undefined };
}

export const ScalaPbOptions_AuxMessageOptions: MessageFns<ScalaPbOptions_AuxMessageOptions> = {
  encode(message: ScalaPbOptions_AuxMessageOptions, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.target !== undefined && message.target !== "") {
      writer.uint32(10).string(message.target);
    }
    if (message.options !== undefined) {
      MessageOptions.encode(message.options, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ScalaPbOptions_AuxMessageOptions {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseScalaPbOptions_AuxMessageOptions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.target = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.options = MessageOptions.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ScalaPbOptions_AuxMessageOptions {
    return {
      target: isSet(object.target) ? globalThis.String(object.target) : "",
      options: isSet(object.options) ? MessageOptions.fromJSON(object.options) : undefined,
    };
  },

  toJSON(message: ScalaPbOptions_AuxMessageOptions): unknown {
    const obj: any = {};
    if (message.target !== undefined && message.target !== "") {
      obj.target = message.target;
    }
    if (message.options !== undefined) {
      obj.options = MessageOptions.toJSON(message.options);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ScalaPbOptions_AuxMessageOptions>, I>>(
    base?: I
  ): ScalaPbOptions_AuxMessageOptions {
    return ScalaPbOptions_AuxMessageOptions.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ScalaPbOptions_AuxMessageOptions>, I>>(
    object: I
  ): ScalaPbOptions_AuxMessageOptions {
    const message = createBaseScalaPbOptions_AuxMessageOptions();
    message.target = object.target ?? "";
    message.options =
      object.options !== undefined && object.options !== null ? MessageOptions.fromPartial(object.options) : undefined;
    return message;
  },
};

function createBaseScalaPbOptions_AuxFieldOptions(): ScalaPbOptions_AuxFieldOptions {
  return { target: "", options: undefined };
}

export const ScalaPbOptions_AuxFieldOptions: MessageFns<ScalaPbOptions_AuxFieldOptions> = {
  encode(message: ScalaPbOptions_AuxFieldOptions, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.target !== undefined && message.target !== "") {
      writer.uint32(10).string(message.target);
    }
    if (message.options !== undefined) {
      FieldOptions.encode(message.options, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ScalaPbOptions_AuxFieldOptions {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseScalaPbOptions_AuxFieldOptions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.target = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.options = FieldOptions.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ScalaPbOptions_AuxFieldOptions {
    return {
      target: isSet(object.target) ? globalThis.String(object.target) : "",
      options: isSet(object.options) ? FieldOptions.fromJSON(object.options) : undefined,
    };
  },

  toJSON(message: ScalaPbOptions_AuxFieldOptions): unknown {
    const obj: any = {};
    if (message.target !== undefined && message.target !== "") {
      obj.target = message.target;
    }
    if (message.options !== undefined) {
      obj.options = FieldOptions.toJSON(message.options);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ScalaPbOptions_AuxFieldOptions>, I>>(base?: I): ScalaPbOptions_AuxFieldOptions {
    return ScalaPbOptions_AuxFieldOptions.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ScalaPbOptions_AuxFieldOptions>, I>>(
    object: I
  ): ScalaPbOptions_AuxFieldOptions {
    const message = createBaseScalaPbOptions_AuxFieldOptions();
    message.target = object.target ?? "";
    message.options =
      object.options !== undefined && object.options !== null ? FieldOptions.fromPartial(object.options) : undefined;
    return message;
  },
};

function createBaseScalaPbOptions_AuxEnumOptions(): ScalaPbOptions_AuxEnumOptions {
  return { target: "", options: undefined };
}

export const ScalaPbOptions_AuxEnumOptions: MessageFns<ScalaPbOptions_AuxEnumOptions> = {
  encode(message: ScalaPbOptions_AuxEnumOptions, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.target !== undefined && message.target !== "") {
      writer.uint32(10).string(message.target);
    }
    if (message.options !== undefined) {
      EnumOptions.encode(message.options, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ScalaPbOptions_AuxEnumOptions {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseScalaPbOptions_AuxEnumOptions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.target = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.options = EnumOptions.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ScalaPbOptions_AuxEnumOptions {
    return {
      target: isSet(object.target) ? globalThis.String(object.target) : "",
      options: isSet(object.options) ? EnumOptions.fromJSON(object.options) : undefined,
    };
  },

  toJSON(message: ScalaPbOptions_AuxEnumOptions): unknown {
    const obj: any = {};
    if (message.target !== undefined && message.target !== "") {
      obj.target = message.target;
    }
    if (message.options !== undefined) {
      obj.options = EnumOptions.toJSON(message.options);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ScalaPbOptions_AuxEnumOptions>, I>>(base?: I): ScalaPbOptions_AuxEnumOptions {
    return ScalaPbOptions_AuxEnumOptions.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ScalaPbOptions_AuxEnumOptions>, I>>(
    object: I
  ): ScalaPbOptions_AuxEnumOptions {
    const message = createBaseScalaPbOptions_AuxEnumOptions();
    message.target = object.target ?? "";
    message.options =
      object.options !== undefined && object.options !== null ? EnumOptions.fromPartial(object.options) : undefined;
    return message;
  },
};

function createBaseScalaPbOptions_AuxEnumValueOptions(): ScalaPbOptions_AuxEnumValueOptions {
  return { target: "", options: undefined };
}

export const ScalaPbOptions_AuxEnumValueOptions: MessageFns<ScalaPbOptions_AuxEnumValueOptions> = {
  encode(message: ScalaPbOptions_AuxEnumValueOptions, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.target !== undefined && message.target !== "") {
      writer.uint32(10).string(message.target);
    }
    if (message.options !== undefined) {
      EnumValueOptions.encode(message.options, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ScalaPbOptions_AuxEnumValueOptions {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseScalaPbOptions_AuxEnumValueOptions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.target = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.options = EnumValueOptions.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ScalaPbOptions_AuxEnumValueOptions {
    return {
      target: isSet(object.target) ? globalThis.String(object.target) : "",
      options: isSet(object.options) ? EnumValueOptions.fromJSON(object.options) : undefined,
    };
  },

  toJSON(message: ScalaPbOptions_AuxEnumValueOptions): unknown {
    const obj: any = {};
    if (message.target !== undefined && message.target !== "") {
      obj.target = message.target;
    }
    if (message.options !== undefined) {
      obj.options = EnumValueOptions.toJSON(message.options);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ScalaPbOptions_AuxEnumValueOptions>, I>>(
    base?: I
  ): ScalaPbOptions_AuxEnumValueOptions {
    return ScalaPbOptions_AuxEnumValueOptions.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ScalaPbOptions_AuxEnumValueOptions>, I>>(
    object: I
  ): ScalaPbOptions_AuxEnumValueOptions {
    const message = createBaseScalaPbOptions_AuxEnumValueOptions();
    message.target = object.target ?? "";
    message.options =
      object.options !== undefined && object.options !== null
        ? EnumValueOptions.fromPartial(object.options)
        : undefined;
    return message;
  },
};

function createBaseMessageOptions(): MessageOptions {
  return {
    extends: [],
    companionExtends: [],
    annotations: [],
    type: "",
    companionAnnotations: [],
    sealedOneofExtends: [],
    noBox: false,
    unknownFieldsAnnotations: [],
  };
}

export const MessageOptions: MessageFns<MessageOptions> = {
  encode(message: MessageOptions, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.extends) {
      writer.uint32(10).string(v!);
    }
    for (const v of message.companionExtends) {
      writer.uint32(18).string(v!);
    }
    for (const v of message.annotations) {
      writer.uint32(26).string(v!);
    }
    if (message.type !== undefined && message.type !== "") {
      writer.uint32(34).string(message.type);
    }
    for (const v of message.companionAnnotations) {
      writer.uint32(42).string(v!);
    }
    for (const v of message.sealedOneofExtends) {
      writer.uint32(50).string(v!);
    }
    if (message.noBox !== undefined && message.noBox !== false) {
      writer.uint32(56).bool(message.noBox);
    }
    for (const v of message.unknownFieldsAnnotations) {
      writer.uint32(66).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MessageOptions {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMessageOptions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.extends.push(reader.string());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.companionExtends.push(reader.string());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.annotations.push(reader.string());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.type = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.companionAnnotations.push(reader.string());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.sealedOneofExtends.push(reader.string());
          continue;
        case 7:
          if (tag !== 56) {
            break;
          }

          message.noBox = reader.bool();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.unknownFieldsAnnotations.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MessageOptions {
    return {
      extends: globalThis.Array.isArray(object?.extends) ? object.extends.map((e: any) => globalThis.String(e)) : [],
      companionExtends: globalThis.Array.isArray(object?.companionExtends)
        ? object.companionExtends.map((e: any) => globalThis.String(e))
        : [],
      annotations: globalThis.Array.isArray(object?.annotations)
        ? object.annotations.map((e: any) => globalThis.String(e))
        : [],
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      companionAnnotations: globalThis.Array.isArray(object?.companionAnnotations)
        ? object.companionAnnotations.map((e: any) => globalThis.String(e))
        : [],
      sealedOneofExtends: globalThis.Array.isArray(object?.sealedOneofExtends)
        ? object.sealedOneofExtends.map((e: any) => globalThis.String(e))
        : [],
      noBox: isSet(object.noBox) ? globalThis.Boolean(object.noBox) : false,
      unknownFieldsAnnotations: globalThis.Array.isArray(object?.unknownFieldsAnnotations)
        ? object.unknownFieldsAnnotations.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: MessageOptions): unknown {
    const obj: any = {};
    if (message.extends?.length) {
      obj.extends = message.extends;
    }
    if (message.companionExtends?.length) {
      obj.companionExtends = message.companionExtends;
    }
    if (message.annotations?.length) {
      obj.annotations = message.annotations;
    }
    if (message.type !== undefined && message.type !== "") {
      obj.type = message.type;
    }
    if (message.companionAnnotations?.length) {
      obj.companionAnnotations = message.companionAnnotations;
    }
    if (message.sealedOneofExtends?.length) {
      obj.sealedOneofExtends = message.sealedOneofExtends;
    }
    if (message.noBox !== undefined && message.noBox !== false) {
      obj.noBox = message.noBox;
    }
    if (message.unknownFieldsAnnotations?.length) {
      obj.unknownFieldsAnnotations = message.unknownFieldsAnnotations;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MessageOptions>, I>>(base?: I): MessageOptions {
    return MessageOptions.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MessageOptions>, I>>(object: I): MessageOptions {
    const message = createBaseMessageOptions();
    message.extends = object.extends?.map(e => e) || [];
    message.companionExtends = object.companionExtends?.map(e => e) || [];
    message.annotations = object.annotations?.map(e => e) || [];
    message.type = object.type ?? "";
    message.companionAnnotations = object.companionAnnotations?.map(e => e) || [];
    message.sealedOneofExtends = object.sealedOneofExtends?.map(e => e) || [];
    message.noBox = object.noBox ?? false;
    message.unknownFieldsAnnotations = object.unknownFieldsAnnotations?.map(e => e) || [];
    return message;
  },
};

function createBaseCollection(): Collection {
  return { type: "", nonEmpty: false, adapter: "" };
}

export const Collection: MessageFns<Collection> = {
  encode(message: Collection, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== undefined && message.type !== "") {
      writer.uint32(10).string(message.type);
    }
    if (message.nonEmpty !== undefined && message.nonEmpty !== false) {
      writer.uint32(16).bool(message.nonEmpty);
    }
    if (message.adapter !== undefined && message.adapter !== "") {
      writer.uint32(26).string(message.adapter);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Collection {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCollection();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.type = reader.string();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.nonEmpty = reader.bool();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.adapter = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Collection {
    return {
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      nonEmpty: isSet(object.nonEmpty) ? globalThis.Boolean(object.nonEmpty) : false,
      adapter: isSet(object.adapter) ? globalThis.String(object.adapter) : "",
    };
  },

  toJSON(message: Collection): unknown {
    const obj: any = {};
    if (message.type !== undefined && message.type !== "") {
      obj.type = message.type;
    }
    if (message.nonEmpty !== undefined && message.nonEmpty !== false) {
      obj.nonEmpty = message.nonEmpty;
    }
    if (message.adapter !== undefined && message.adapter !== "") {
      obj.adapter = message.adapter;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Collection>, I>>(base?: I): Collection {
    return Collection.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Collection>, I>>(object: I): Collection {
    const message = createBaseCollection();
    message.type = object.type ?? "";
    message.nonEmpty = object.nonEmpty ?? false;
    message.adapter = object.adapter ?? "";
    return message;
  },
};

function createBaseFieldOptions(): FieldOptions {
  return {
    type: "",
    scalaName: "",
    collectionType: "",
    collection: undefined,
    keyType: "",
    valueType: "",
    annotations: [],
    mapType: "",
    noBox: false,
    required: false,
  };
}

export const FieldOptions: MessageFns<FieldOptions> = {
  encode(message: FieldOptions, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== undefined && message.type !== "") {
      writer.uint32(10).string(message.type);
    }
    if (message.scalaName !== undefined && message.scalaName !== "") {
      writer.uint32(18).string(message.scalaName);
    }
    if (message.collectionType !== undefined && message.collectionType !== "") {
      writer.uint32(26).string(message.collectionType);
    }
    if (message.collection !== undefined) {
      Collection.encode(message.collection, writer.uint32(66).fork()).join();
    }
    if (message.keyType !== undefined && message.keyType !== "") {
      writer.uint32(34).string(message.keyType);
    }
    if (message.valueType !== undefined && message.valueType !== "") {
      writer.uint32(42).string(message.valueType);
    }
    for (const v of message.annotations) {
      writer.uint32(50).string(v!);
    }
    if (message.mapType !== undefined && message.mapType !== "") {
      writer.uint32(58).string(message.mapType);
    }
    if (message.noBox !== undefined && message.noBox !== false) {
      writer.uint32(240).bool(message.noBox);
    }
    if (message.required !== undefined && message.required !== false) {
      writer.uint32(248).bool(message.required);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FieldOptions {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFieldOptions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.type = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.scalaName = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.collectionType = reader.string();
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.collection = Collection.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.keyType = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.valueType = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.annotations.push(reader.string());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.mapType = reader.string();
          continue;
        case 30:
          if (tag !== 240) {
            break;
          }

          message.noBox = reader.bool();
          continue;
        case 31:
          if (tag !== 248) {
            break;
          }

          message.required = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FieldOptions {
    return {
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      scalaName: isSet(object.scalaName) ? globalThis.String(object.scalaName) : "",
      collectionType: isSet(object.collectionType) ? globalThis.String(object.collectionType) : "",
      collection: isSet(object.collection) ? Collection.fromJSON(object.collection) : undefined,
      keyType: isSet(object.keyType) ? globalThis.String(object.keyType) : "",
      valueType: isSet(object.valueType) ? globalThis.String(object.valueType) : "",
      annotations: globalThis.Array.isArray(object?.annotations)
        ? object.annotations.map((e: any) => globalThis.String(e))
        : [],
      mapType: isSet(object.mapType) ? globalThis.String(object.mapType) : "",
      noBox: isSet(object.noBox) ? globalThis.Boolean(object.noBox) : false,
      required: isSet(object.required) ? globalThis.Boolean(object.required) : false,
    };
  },

  toJSON(message: FieldOptions): unknown {
    const obj: any = {};
    if (message.type !== undefined && message.type !== "") {
      obj.type = message.type;
    }
    if (message.scalaName !== undefined && message.scalaName !== "") {
      obj.scalaName = message.scalaName;
    }
    if (message.collectionType !== undefined && message.collectionType !== "") {
      obj.collectionType = message.collectionType;
    }
    if (message.collection !== undefined) {
      obj.collection = Collection.toJSON(message.collection);
    }
    if (message.keyType !== undefined && message.keyType !== "") {
      obj.keyType = message.keyType;
    }
    if (message.valueType !== undefined && message.valueType !== "") {
      obj.valueType = message.valueType;
    }
    if (message.annotations?.length) {
      obj.annotations = message.annotations;
    }
    if (message.mapType !== undefined && message.mapType !== "") {
      obj.mapType = message.mapType;
    }
    if (message.noBox !== undefined && message.noBox !== false) {
      obj.noBox = message.noBox;
    }
    if (message.required !== undefined && message.required !== false) {
      obj.required = message.required;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FieldOptions>, I>>(base?: I): FieldOptions {
    return FieldOptions.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FieldOptions>, I>>(object: I): FieldOptions {
    const message = createBaseFieldOptions();
    message.type = object.type ?? "";
    message.scalaName = object.scalaName ?? "";
    message.collectionType = object.collectionType ?? "";
    message.collection =
      object.collection !== undefined && object.collection !== null
        ? Collection.fromPartial(object.collection)
        : undefined;
    message.keyType = object.keyType ?? "";
    message.valueType = object.valueType ?? "";
    message.annotations = object.annotations?.map(e => e) || [];
    message.mapType = object.mapType ?? "";
    message.noBox = object.noBox ?? false;
    message.required = object.required ?? false;
    return message;
  },
};

function createBaseEnumOptions(): EnumOptions {
  return {
    extends: [],
    companionExtends: [],
    type: "",
    baseAnnotations: [],
    recognizedAnnotations: [],
    unrecognizedAnnotations: [],
  };
}

export const EnumOptions: MessageFns<EnumOptions> = {
  encode(message: EnumOptions, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.extends) {
      writer.uint32(10).string(v!);
    }
    for (const v of message.companionExtends) {
      writer.uint32(18).string(v!);
    }
    if (message.type !== undefined && message.type !== "") {
      writer.uint32(26).string(message.type);
    }
    for (const v of message.baseAnnotations) {
      writer.uint32(34).string(v!);
    }
    for (const v of message.recognizedAnnotations) {
      writer.uint32(42).string(v!);
    }
    for (const v of message.unrecognizedAnnotations) {
      writer.uint32(50).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EnumOptions {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEnumOptions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.extends.push(reader.string());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.companionExtends.push(reader.string());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.type = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.baseAnnotations.push(reader.string());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.recognizedAnnotations.push(reader.string());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.unrecognizedAnnotations.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EnumOptions {
    return {
      extends: globalThis.Array.isArray(object?.extends) ? object.extends.map((e: any) => globalThis.String(e)) : [],
      companionExtends: globalThis.Array.isArray(object?.companionExtends)
        ? object.companionExtends.map((e: any) => globalThis.String(e))
        : [],
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      baseAnnotations: globalThis.Array.isArray(object?.baseAnnotations)
        ? object.baseAnnotations.map((e: any) => globalThis.String(e))
        : [],
      recognizedAnnotations: globalThis.Array.isArray(object?.recognizedAnnotations)
        ? object.recognizedAnnotations.map((e: any) => globalThis.String(e))
        : [],
      unrecognizedAnnotations: globalThis.Array.isArray(object?.unrecognizedAnnotations)
        ? object.unrecognizedAnnotations.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: EnumOptions): unknown {
    const obj: any = {};
    if (message.extends?.length) {
      obj.extends = message.extends;
    }
    if (message.companionExtends?.length) {
      obj.companionExtends = message.companionExtends;
    }
    if (message.type !== undefined && message.type !== "") {
      obj.type = message.type;
    }
    if (message.baseAnnotations?.length) {
      obj.baseAnnotations = message.baseAnnotations;
    }
    if (message.recognizedAnnotations?.length) {
      obj.recognizedAnnotations = message.recognizedAnnotations;
    }
    if (message.unrecognizedAnnotations?.length) {
      obj.unrecognizedAnnotations = message.unrecognizedAnnotations;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EnumOptions>, I>>(base?: I): EnumOptions {
    return EnumOptions.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EnumOptions>, I>>(object: I): EnumOptions {
    const message = createBaseEnumOptions();
    message.extends = object.extends?.map(e => e) || [];
    message.companionExtends = object.companionExtends?.map(e => e) || [];
    message.type = object.type ?? "";
    message.baseAnnotations = object.baseAnnotations?.map(e => e) || [];
    message.recognizedAnnotations = object.recognizedAnnotations?.map(e => e) || [];
    message.unrecognizedAnnotations = object.unrecognizedAnnotations?.map(e => e) || [];
    return message;
  },
};

function createBaseEnumValueOptions(): EnumValueOptions {
  return { extends: [], scalaName: "", annotations: [] };
}

export const EnumValueOptions: MessageFns<EnumValueOptions> = {
  encode(message: EnumValueOptions, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.extends) {
      writer.uint32(10).string(v!);
    }
    if (message.scalaName !== undefined && message.scalaName !== "") {
      writer.uint32(18).string(message.scalaName);
    }
    for (const v of message.annotations) {
      writer.uint32(26).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EnumValueOptions {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEnumValueOptions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.extends.push(reader.string());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.scalaName = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.annotations.push(reader.string());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EnumValueOptions {
    return {
      extends: globalThis.Array.isArray(object?.extends) ? object.extends.map((e: any) => globalThis.String(e)) : [],
      scalaName: isSet(object.scalaName) ? globalThis.String(object.scalaName) : "",
      annotations: globalThis.Array.isArray(object?.annotations)
        ? object.annotations.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: EnumValueOptions): unknown {
    const obj: any = {};
    if (message.extends?.length) {
      obj.extends = message.extends;
    }
    if (message.scalaName !== undefined && message.scalaName !== "") {
      obj.scalaName = message.scalaName;
    }
    if (message.annotations?.length) {
      obj.annotations = message.annotations;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EnumValueOptions>, I>>(base?: I): EnumValueOptions {
    return EnumValueOptions.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EnumValueOptions>, I>>(object: I): EnumValueOptions {
    const message = createBaseEnumValueOptions();
    message.extends = object.extends?.map(e => e) || [];
    message.scalaName = object.scalaName ?? "";
    message.annotations = object.annotations?.map(e => e) || [];
    return message;
  },
};

function createBaseOneofOptions(): OneofOptions {
  return { extends: [], scalaName: "" };
}

export const OneofOptions: MessageFns<OneofOptions> = {
  encode(message: OneofOptions, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.extends) {
      writer.uint32(10).string(v!);
    }
    if (message.scalaName !== undefined && message.scalaName !== "") {
      writer.uint32(18).string(message.scalaName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): OneofOptions {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseOneofOptions();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.extends.push(reader.string());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.scalaName = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): OneofOptions {
    return {
      extends: globalThis.Array.isArray(object?.extends) ? object.extends.map((e: any) => globalThis.String(e)) : [],
      scalaName: isSet(object.scalaName) ? globalThis.String(object.scalaName) : "",
    };
  },

  toJSON(message: OneofOptions): unknown {
    const obj: any = {};
    if (message.extends?.length) {
      obj.extends = message.extends;
    }
    if (message.scalaName !== undefined && message.scalaName !== "") {
      obj.scalaName = message.scalaName;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<OneofOptions>, I>>(base?: I): OneofOptions {
    return OneofOptions.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<OneofOptions>, I>>(object: I): OneofOptions {
    const message = createBaseOneofOptions();
    message.extends = object.extends?.map(e => e) || [];
    message.scalaName = object.scalaName ?? "";
    return message;
  },
};

function createBaseFieldTransformation(): FieldTransformation {
  return { when: undefined, matchType: 0, set: undefined };
}

export const FieldTransformation: MessageFns<FieldTransformation> = {
  encode(message: FieldTransformation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.when !== undefined) {
      FieldDescriptorProto.encode(message.when, writer.uint32(10).fork()).join();
    }
    if (message.matchType !== undefined && message.matchType !== 0) {
      writer.uint32(16).int32(message.matchType);
    }
    if (message.set !== undefined) {
      FieldOptions1.encode(message.set, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FieldTransformation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFieldTransformation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.when = FieldDescriptorProto.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.matchType = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.set = FieldOptions1.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FieldTransformation {
    return {
      when: isSet(object.when) ? FieldDescriptorProto.fromJSON(object.when) : undefined,
      matchType: isSet(object.matchType) ? matchTypeFromJSON(object.matchType) : 0,
      set: isSet(object.set) ? FieldOptions1.fromJSON(object.set) : undefined,
    };
  },

  toJSON(message: FieldTransformation): unknown {
    const obj: any = {};
    if (message.when !== undefined) {
      obj.when = FieldDescriptorProto.toJSON(message.when);
    }
    if (message.matchType !== undefined && message.matchType !== 0) {
      obj.matchType = matchTypeToJSON(message.matchType);
    }
    if (message.set !== undefined) {
      obj.set = FieldOptions1.toJSON(message.set);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FieldTransformation>, I>>(base?: I): FieldTransformation {
    return FieldTransformation.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FieldTransformation>, I>>(object: I): FieldTransformation {
    const message = createBaseFieldTransformation();
    message.when =
      object.when !== undefined && object.when !== null ? FieldDescriptorProto.fromPartial(object.when) : undefined;
    message.matchType = object.matchType ?? 0;
    message.set = object.set !== undefined && object.set !== null ? FieldOptions1.fromPartial(object.set) : undefined;
    return message;
  },
};

function createBasePreprocessorOutput(): PreprocessorOutput {
  return { optionsByFile: {} };
}

export const PreprocessorOutput: MessageFns<PreprocessorOutput> = {
  encode(message: PreprocessorOutput, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    Object.entries(message.optionsByFile).forEach(([key, value]) => {
      PreprocessorOutput_OptionsByFileEntry.encode({ key: key as any, value }, writer.uint32(10).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PreprocessorOutput {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePreprocessorOutput();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          const entry1 = PreprocessorOutput_OptionsByFileEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.optionsByFile[entry1.key] = entry1.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PreprocessorOutput {
    return {
      optionsByFile: isObject(object.optionsByFile)
        ? Object.entries(object.optionsByFile).reduce<{ [key: string]: ScalaPbOptions }>((acc, [key, value]) => {
            acc[key] = ScalaPbOptions.fromJSON(value);
            return acc;
          }, {})
        : {},
    };
  },

  toJSON(message: PreprocessorOutput): unknown {
    const obj: any = {};
    if (message.optionsByFile) {
      const entries = Object.entries(message.optionsByFile);
      if (entries.length > 0) {
        obj.optionsByFile = {};
        entries.forEach(([k, v]) => {
          obj.optionsByFile[k] = ScalaPbOptions.toJSON(v);
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PreprocessorOutput>, I>>(base?: I): PreprocessorOutput {
    return PreprocessorOutput.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PreprocessorOutput>, I>>(object: I): PreprocessorOutput {
    const message = createBasePreprocessorOutput();
    message.optionsByFile = Object.entries(object.optionsByFile ?? {}).reduce<{ [key: string]: ScalaPbOptions }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = ScalaPbOptions.fromPartial(value);
        }
        return acc;
      },
      {}
    );
    return message;
  },
};

function createBasePreprocessorOutput_OptionsByFileEntry(): PreprocessorOutput_OptionsByFileEntry {
  return { key: "", value: undefined };
}

export const PreprocessorOutput_OptionsByFileEntry: MessageFns<PreprocessorOutput_OptionsByFileEntry> = {
  encode(message: PreprocessorOutput_OptionsByFileEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      ScalaPbOptions.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PreprocessorOutput_OptionsByFileEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePreprocessorOutput_OptionsByFileEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = ScalaPbOptions.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PreprocessorOutput_OptionsByFileEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? ScalaPbOptions.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: PreprocessorOutput_OptionsByFileEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = ScalaPbOptions.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PreprocessorOutput_OptionsByFileEntry>, I>>(
    base?: I
  ): PreprocessorOutput_OptionsByFileEntry {
    return PreprocessorOutput_OptionsByFileEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PreprocessorOutput_OptionsByFileEntry>, I>>(
    object: I
  ): PreprocessorOutput_OptionsByFileEntry {
    const message = createBasePreprocessorOutput_OptionsByFileEntry();
    message.key = object.key ?? "";
    message.value =
      object.value !== undefined && object.value !== null ? ScalaPbOptions.fromPartial(object.value) : undefined;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin
  ? T
  : T extends globalThis.Array<infer U>
    ? globalThis.Array<DeepPartial<U>>
    : T extends ReadonlyArray<infer U>
      ? ReadonlyArray<DeepPartial<U>>
      : T extends {}
        ? { [K in keyof T]?: DeepPartial<T[K]> }
        : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin
  ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
