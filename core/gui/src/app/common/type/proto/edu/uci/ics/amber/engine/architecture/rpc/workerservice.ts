// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               v5.28.3
// source: edu/uci/ics/amber/engine/architecture/rpc/workerservice.proto

/* eslint-disable */
import { BinaryReader } from "@bufbuild/protobuf/wire";
import {
  AddInputChannelRequest,
  AddPartitioningRequest,
  AssignPortRequest,
  DebugCommandRequest,
  EmptyRequest,
  EvaluatePythonExpressionRequest,
  FinalizeCheckpointRequest,
  InitializeExecutorRequest,
  PrepareCheckpointRequest,
} from "./controlcommands";
import {
  EmptyReturn,
  EvaluatedValue,
  FinalizeCheckpointResponse,
  WorkerMetricsResponse,
  WorkerStateResponse,
} from "./controlreturns";

export const protobufPackage = "edu.uci.ics.amber.engine.architecture.rpc";

/** RPC Service */
export interface WorkerService {
  AddInputChannel(request: AddInputChannelRequest): Promise<EmptyReturn>;
  AddPartitioning(request: AddPartitioningRequest): Promise<EmptyReturn>;
  AssignPort(request: AssignPortRequest): Promise<EmptyReturn>;
  FinalizeCheckpoint(request: FinalizeCheckpointRequest): Promise<FinalizeCheckpointResponse>;
  FlushNetworkBuffer(request: EmptyRequest): Promise<EmptyReturn>;
  InitializeExecutor(request: InitializeExecutorRequest): Promise<EmptyReturn>;
  OpenExecutor(request: EmptyRequest): Promise<EmptyReturn>;
  PauseWorker(request: EmptyRequest): Promise<WorkerStateResponse>;
  PrepareCheckpoint(request: PrepareCheckpointRequest): Promise<EmptyReturn>;
  QueryStatistics(request: EmptyRequest): Promise<WorkerMetricsResponse>;
  ResumeWorker(request: EmptyRequest): Promise<WorkerStateResponse>;
  RetrieveState(request: EmptyRequest): Promise<EmptyReturn>;
  RetryCurrentTuple(request: EmptyRequest): Promise<EmptyReturn>;
  StartWorker(request: EmptyRequest): Promise<WorkerStateResponse>;
  DebugCommand(request: DebugCommandRequest): Promise<EmptyReturn>;
  EvaluatePythonExpression(request: EvaluatePythonExpressionRequest): Promise<EvaluatedValue>;
  NoOperation(request: EmptyRequest): Promise<EmptyReturn>;
}

export const WorkerServiceServiceName = "edu.uci.ics.amber.engine.architecture.rpc.WorkerService";
export class WorkerServiceClientImpl implements WorkerService {
  private readonly rpc: Rpc;
  private readonly service: string;
  constructor(rpc: Rpc, opts?: { service?: string }) {
    this.service = opts?.service || WorkerServiceServiceName;
    this.rpc = rpc;
    this.AddInputChannel = this.AddInputChannel.bind(this);
    this.AddPartitioning = this.AddPartitioning.bind(this);
    this.AssignPort = this.AssignPort.bind(this);
    this.FinalizeCheckpoint = this.FinalizeCheckpoint.bind(this);
    this.FlushNetworkBuffer = this.FlushNetworkBuffer.bind(this);
    this.InitializeExecutor = this.InitializeExecutor.bind(this);
    this.OpenExecutor = this.OpenExecutor.bind(this);
    this.PauseWorker = this.PauseWorker.bind(this);
    this.PrepareCheckpoint = this.PrepareCheckpoint.bind(this);
    this.QueryStatistics = this.QueryStatistics.bind(this);
    this.ResumeWorker = this.ResumeWorker.bind(this);
    this.RetrieveState = this.RetrieveState.bind(this);
    this.RetryCurrentTuple = this.RetryCurrentTuple.bind(this);
    this.StartWorker = this.StartWorker.bind(this);
    this.DebugCommand = this.DebugCommand.bind(this);
    this.EvaluatePythonExpression = this.EvaluatePythonExpression.bind(this);
    this.NoOperation = this.NoOperation.bind(this);
  }
  AddInputChannel(request: AddInputChannelRequest): Promise<EmptyReturn> {
    const data = AddInputChannelRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "AddInputChannel", data);
    return promise.then((data) => EmptyReturn.decode(new BinaryReader(data)));
  }

  AddPartitioning(request: AddPartitioningRequest): Promise<EmptyReturn> {
    const data = AddPartitioningRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "AddPartitioning", data);
    return promise.then((data) => EmptyReturn.decode(new BinaryReader(data)));
  }

  AssignPort(request: AssignPortRequest): Promise<EmptyReturn> {
    const data = AssignPortRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "AssignPort", data);
    return promise.then((data) => EmptyReturn.decode(new BinaryReader(data)));
  }

  FinalizeCheckpoint(request: FinalizeCheckpointRequest): Promise<FinalizeCheckpointResponse> {
    const data = FinalizeCheckpointRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "FinalizeCheckpoint", data);
    return promise.then((data) => FinalizeCheckpointResponse.decode(new BinaryReader(data)));
  }

  FlushNetworkBuffer(request: EmptyRequest): Promise<EmptyReturn> {
    const data = EmptyRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "FlushNetworkBuffer", data);
    return promise.then((data) => EmptyReturn.decode(new BinaryReader(data)));
  }

  InitializeExecutor(request: InitializeExecutorRequest): Promise<EmptyReturn> {
    const data = InitializeExecutorRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "InitializeExecutor", data);
    return promise.then((data) => EmptyReturn.decode(new BinaryReader(data)));
  }

  OpenExecutor(request: EmptyRequest): Promise<EmptyReturn> {
    const data = EmptyRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "OpenExecutor", data);
    return promise.then((data) => EmptyReturn.decode(new BinaryReader(data)));
  }

  PauseWorker(request: EmptyRequest): Promise<WorkerStateResponse> {
    const data = EmptyRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "PauseWorker", data);
    return promise.then((data) => WorkerStateResponse.decode(new BinaryReader(data)));
  }

  PrepareCheckpoint(request: PrepareCheckpointRequest): Promise<EmptyReturn> {
    const data = PrepareCheckpointRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "PrepareCheckpoint", data);
    return promise.then((data) => EmptyReturn.decode(new BinaryReader(data)));
  }

  QueryStatistics(request: EmptyRequest): Promise<WorkerMetricsResponse> {
    const data = EmptyRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "QueryStatistics", data);
    return promise.then((data) => WorkerMetricsResponse.decode(new BinaryReader(data)));
  }

  ResumeWorker(request: EmptyRequest): Promise<WorkerStateResponse> {
    const data = EmptyRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "ResumeWorker", data);
    return promise.then((data) => WorkerStateResponse.decode(new BinaryReader(data)));
  }

  RetrieveState(request: EmptyRequest): Promise<EmptyReturn> {
    const data = EmptyRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "RetrieveState", data);
    return promise.then((data) => EmptyReturn.decode(new BinaryReader(data)));
  }

  RetryCurrentTuple(request: EmptyRequest): Promise<EmptyReturn> {
    const data = EmptyRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "RetryCurrentTuple", data);
    return promise.then((data) => EmptyReturn.decode(new BinaryReader(data)));
  }

  StartWorker(request: EmptyRequest): Promise<WorkerStateResponse> {
    const data = EmptyRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "StartWorker", data);
    return promise.then((data) => WorkerStateResponse.decode(new BinaryReader(data)));
  }

  DebugCommand(request: DebugCommandRequest): Promise<EmptyReturn> {
    const data = DebugCommandRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "DebugCommand", data);
    return promise.then((data) => EmptyReturn.decode(new BinaryReader(data)));
  }

  EvaluatePythonExpression(request: EvaluatePythonExpressionRequest): Promise<EvaluatedValue> {
    const data = EvaluatePythonExpressionRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "EvaluatePythonExpression", data);
    return promise.then((data) => EvaluatedValue.decode(new BinaryReader(data)));
  }

  NoOperation(request: EmptyRequest): Promise<EmptyReturn> {
    const data = EmptyRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "NoOperation", data);
    return promise.then((data) => EmptyReturn.decode(new BinaryReader(data)));
  }
}

interface Rpc {
  request(service: string, method: string, data: Uint8Array): Promise<Uint8Array>;
}
