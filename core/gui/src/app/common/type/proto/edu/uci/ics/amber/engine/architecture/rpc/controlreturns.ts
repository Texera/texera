// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               v5.28.3
// source: edu/uci/ics/amber/engine/architecture/rpc/controlreturns.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { WorkerMetrics, WorkerState, workerStateFromJSON, workerStateToJSON } from "../worker/statistics";

export const protobufPackage = "edu.uci.ics.amber.engine.architecture.rpc";

export enum ErrorLanguage {
  PYTHON = 0,
  SCALA = 1,
  UNRECOGNIZED = -1,
}

export function errorLanguageFromJSON(object: any): ErrorLanguage {
  switch (object) {
    case 0:
    case "PYTHON":
      return ErrorLanguage.PYTHON;
    case 1:
    case "SCALA":
      return ErrorLanguage.SCALA;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ErrorLanguage.UNRECOGNIZED;
  }
}

export function errorLanguageToJSON(object: ErrorLanguage): string {
  switch (object) {
    case ErrorLanguage.PYTHON:
      return "PYTHON";
    case ErrorLanguage.SCALA:
      return "SCALA";
    case ErrorLanguage.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum WorkflowAggregatedState {
  UNINITIALIZED = 0,
  READY = 1,
  RUNNING = 2,
  PAUSING = 3,
  PAUSED = 4,
  RESUMING = 5,
  COMPLETED = 6,
  FAILED = 7,
  UNKNOWN = 8,
  KILLED = 9,
  UNRECOGNIZED = -1,
}

export function workflowAggregatedStateFromJSON(object: any): WorkflowAggregatedState {
  switch (object) {
    case 0:
    case "UNINITIALIZED":
      return WorkflowAggregatedState.UNINITIALIZED;
    case 1:
    case "READY":
      return WorkflowAggregatedState.READY;
    case 2:
    case "RUNNING":
      return WorkflowAggregatedState.RUNNING;
    case 3:
    case "PAUSING":
      return WorkflowAggregatedState.PAUSING;
    case 4:
    case "PAUSED":
      return WorkflowAggregatedState.PAUSED;
    case 5:
    case "RESUMING":
      return WorkflowAggregatedState.RESUMING;
    case 6:
    case "COMPLETED":
      return WorkflowAggregatedState.COMPLETED;
    case 7:
    case "FAILED":
      return WorkflowAggregatedState.FAILED;
    case 8:
    case "UNKNOWN":
      return WorkflowAggregatedState.UNKNOWN;
    case 9:
    case "KILLED":
      return WorkflowAggregatedState.KILLED;
    case -1:
    case "UNRECOGNIZED":
    default:
      return WorkflowAggregatedState.UNRECOGNIZED;
  }
}

export function workflowAggregatedStateToJSON(object: WorkflowAggregatedState): string {
  switch (object) {
    case WorkflowAggregatedState.UNINITIALIZED:
      return "UNINITIALIZED";
    case WorkflowAggregatedState.READY:
      return "READY";
    case WorkflowAggregatedState.RUNNING:
      return "RUNNING";
    case WorkflowAggregatedState.PAUSING:
      return "PAUSING";
    case WorkflowAggregatedState.PAUSED:
      return "PAUSED";
    case WorkflowAggregatedState.RESUMING:
      return "RESUMING";
    case WorkflowAggregatedState.COMPLETED:
      return "COMPLETED";
    case WorkflowAggregatedState.FAILED:
      return "FAILED";
    case WorkflowAggregatedState.UNKNOWN:
      return "UNKNOWN";
    case WorkflowAggregatedState.KILLED:
      return "KILLED";
    case WorkflowAggregatedState.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

/** The generic return message */
export interface ControlReturn {
  /** controller responses */
  retrieveWorkflowStateResponse?: RetrieveWorkflowStateResponse | undefined;
  propagateChannelMarkerResponse?: PropagateChannelMarkerResponse | undefined;
  takeGlobalCheckpointResponse?: TakeGlobalCheckpointResponse | undefined;
  evaluatePythonExpressionResponse?: EvaluatePythonExpressionResponse | undefined;
  startWorkflowResponse?:
    | StartWorkflowResponse
    | undefined;
  /** worker responses */
  workerStateResponse?: WorkerStateResponse | undefined;
  workerMetricsResponse?: WorkerMetricsResponse | undefined;
  finalizeCheckpointResponse?:
    | FinalizeCheckpointResponse
    | undefined;
  /** common responses */
  error?: ControlError | undefined;
  emptyReturn?: EmptyReturn | undefined;
  stringResponse?: StringResponse | undefined;
  intResponse?: IntResponse | undefined;
}

export interface EmptyReturn {
}

export interface ControlError {
  errorMessage: string;
  errorDetails: string;
  stackTrace: string;
  language: ErrorLanguage;
}

export interface ReturnInvocation {
  commandId: number;
  returnValue: ControlReturn | undefined;
}

export interface StringResponse {
  value: string;
}

export interface IntResponse {
  value: number;
}

export interface RetrieveWorkflowStateResponse {
  state: { [key: string]: string };
}

export interface RetrieveWorkflowStateResponse_StateEntry {
  key: string;
  value: string;
}

export interface FinalizeCheckpointResponse {
  size: number;
}

export interface PropagateChannelMarkerResponse {
  returns: { [key: string]: ControlReturn };
}

export interface PropagateChannelMarkerResponse_ReturnsEntry {
  key: string;
  value: ControlReturn | undefined;
}

export interface TakeGlobalCheckpointResponse {
  totalSize: number;
}

export interface TypedValue {
  expression: string;
  valueRef: string;
  valueStr: string;
  valueType: string;
  expandable: boolean;
}

export interface EvaluatedValue {
  value: TypedValue | undefined;
  attributes: TypedValue[];
}

export interface EvaluatePythonExpressionResponse {
  values: EvaluatedValue[];
}

export interface StartWorkflowResponse {
  workflowState: WorkflowAggregatedState;
}

export interface WorkerStateResponse {
  state: WorkerState;
}

export interface WorkerMetricsResponse {
  metrics: WorkerMetrics | undefined;
}

function createBaseControlReturn(): ControlReturn {
  return {
    retrieveWorkflowStateResponse: undefined,
    propagateChannelMarkerResponse: undefined,
    takeGlobalCheckpointResponse: undefined,
    evaluatePythonExpressionResponse: undefined,
    startWorkflowResponse: undefined,
    workerStateResponse: undefined,
    workerMetricsResponse: undefined,
    finalizeCheckpointResponse: undefined,
    error: undefined,
    emptyReturn: undefined,
    stringResponse: undefined,
    intResponse: undefined,
  };
}

export const ControlReturn: MessageFns<ControlReturn> = {
  encode(message: ControlReturn, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.retrieveWorkflowStateResponse !== undefined) {
      RetrieveWorkflowStateResponse.encode(message.retrieveWorkflowStateResponse, writer.uint32(10).fork()).join();
    }
    if (message.propagateChannelMarkerResponse !== undefined) {
      PropagateChannelMarkerResponse.encode(message.propagateChannelMarkerResponse, writer.uint32(18).fork()).join();
    }
    if (message.takeGlobalCheckpointResponse !== undefined) {
      TakeGlobalCheckpointResponse.encode(message.takeGlobalCheckpointResponse, writer.uint32(26).fork()).join();
    }
    if (message.evaluatePythonExpressionResponse !== undefined) {
      EvaluatePythonExpressionResponse.encode(message.evaluatePythonExpressionResponse, writer.uint32(34).fork())
        .join();
    }
    if (message.startWorkflowResponse !== undefined) {
      StartWorkflowResponse.encode(message.startWorkflowResponse, writer.uint32(42).fork()).join();
    }
    if (message.workerStateResponse !== undefined) {
      WorkerStateResponse.encode(message.workerStateResponse, writer.uint32(402).fork()).join();
    }
    if (message.workerMetricsResponse !== undefined) {
      WorkerMetricsResponse.encode(message.workerMetricsResponse, writer.uint32(410).fork()).join();
    }
    if (message.finalizeCheckpointResponse !== undefined) {
      FinalizeCheckpointResponse.encode(message.finalizeCheckpointResponse, writer.uint32(418).fork()).join();
    }
    if (message.error !== undefined) {
      ControlError.encode(message.error, writer.uint32(810).fork()).join();
    }
    if (message.emptyReturn !== undefined) {
      EmptyReturn.encode(message.emptyReturn, writer.uint32(818).fork()).join();
    }
    if (message.stringResponse !== undefined) {
      StringResponse.encode(message.stringResponse, writer.uint32(826).fork()).join();
    }
    if (message.intResponse !== undefined) {
      IntResponse.encode(message.intResponse, writer.uint32(834).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ControlReturn {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseControlReturn();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.retrieveWorkflowStateResponse = RetrieveWorkflowStateResponse.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.propagateChannelMarkerResponse = PropagateChannelMarkerResponse.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.takeGlobalCheckpointResponse = TakeGlobalCheckpointResponse.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.evaluatePythonExpressionResponse = EvaluatePythonExpressionResponse.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.startWorkflowResponse = StartWorkflowResponse.decode(reader, reader.uint32());
          continue;
        case 50:
          if (tag !== 402) {
            break;
          }

          message.workerStateResponse = WorkerStateResponse.decode(reader, reader.uint32());
          continue;
        case 51:
          if (tag !== 410) {
            break;
          }

          message.workerMetricsResponse = WorkerMetricsResponse.decode(reader, reader.uint32());
          continue;
        case 52:
          if (tag !== 418) {
            break;
          }

          message.finalizeCheckpointResponse = FinalizeCheckpointResponse.decode(reader, reader.uint32());
          continue;
        case 101:
          if (tag !== 810) {
            break;
          }

          message.error = ControlError.decode(reader, reader.uint32());
          continue;
        case 102:
          if (tag !== 818) {
            break;
          }

          message.emptyReturn = EmptyReturn.decode(reader, reader.uint32());
          continue;
        case 103:
          if (tag !== 826) {
            break;
          }

          message.stringResponse = StringResponse.decode(reader, reader.uint32());
          continue;
        case 104:
          if (tag !== 834) {
            break;
          }

          message.intResponse = IntResponse.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ControlReturn {
    return {
      retrieveWorkflowStateResponse: isSet(object.retrieveWorkflowStateResponse)
        ? RetrieveWorkflowStateResponse.fromJSON(object.retrieveWorkflowStateResponse)
        : undefined,
      propagateChannelMarkerResponse: isSet(object.propagateChannelMarkerResponse)
        ? PropagateChannelMarkerResponse.fromJSON(object.propagateChannelMarkerResponse)
        : undefined,
      takeGlobalCheckpointResponse: isSet(object.takeGlobalCheckpointResponse)
        ? TakeGlobalCheckpointResponse.fromJSON(object.takeGlobalCheckpointResponse)
        : undefined,
      evaluatePythonExpressionResponse: isSet(object.evaluatePythonExpressionResponse)
        ? EvaluatePythonExpressionResponse.fromJSON(object.evaluatePythonExpressionResponse)
        : undefined,
      startWorkflowResponse: isSet(object.startWorkflowResponse)
        ? StartWorkflowResponse.fromJSON(object.startWorkflowResponse)
        : undefined,
      workerStateResponse: isSet(object.workerStateResponse)
        ? WorkerStateResponse.fromJSON(object.workerStateResponse)
        : undefined,
      workerMetricsResponse: isSet(object.workerMetricsResponse)
        ? WorkerMetricsResponse.fromJSON(object.workerMetricsResponse)
        : undefined,
      finalizeCheckpointResponse: isSet(object.finalizeCheckpointResponse)
        ? FinalizeCheckpointResponse.fromJSON(object.finalizeCheckpointResponse)
        : undefined,
      error: isSet(object.error) ? ControlError.fromJSON(object.error) : undefined,
      emptyReturn: isSet(object.emptyReturn) ? EmptyReturn.fromJSON(object.emptyReturn) : undefined,
      stringResponse: isSet(object.stringResponse) ? StringResponse.fromJSON(object.stringResponse) : undefined,
      intResponse: isSet(object.intResponse) ? IntResponse.fromJSON(object.intResponse) : undefined,
    };
  },

  toJSON(message: ControlReturn): unknown {
    const obj: any = {};
    if (message.retrieveWorkflowStateResponse !== undefined) {
      obj.retrieveWorkflowStateResponse = RetrieveWorkflowStateResponse.toJSON(message.retrieveWorkflowStateResponse);
    }
    if (message.propagateChannelMarkerResponse !== undefined) {
      obj.propagateChannelMarkerResponse = PropagateChannelMarkerResponse.toJSON(
        message.propagateChannelMarkerResponse,
      );
    }
    if (message.takeGlobalCheckpointResponse !== undefined) {
      obj.takeGlobalCheckpointResponse = TakeGlobalCheckpointResponse.toJSON(message.takeGlobalCheckpointResponse);
    }
    if (message.evaluatePythonExpressionResponse !== undefined) {
      obj.evaluatePythonExpressionResponse = EvaluatePythonExpressionResponse.toJSON(
        message.evaluatePythonExpressionResponse,
      );
    }
    if (message.startWorkflowResponse !== undefined) {
      obj.startWorkflowResponse = StartWorkflowResponse.toJSON(message.startWorkflowResponse);
    }
    if (message.workerStateResponse !== undefined) {
      obj.workerStateResponse = WorkerStateResponse.toJSON(message.workerStateResponse);
    }
    if (message.workerMetricsResponse !== undefined) {
      obj.workerMetricsResponse = WorkerMetricsResponse.toJSON(message.workerMetricsResponse);
    }
    if (message.finalizeCheckpointResponse !== undefined) {
      obj.finalizeCheckpointResponse = FinalizeCheckpointResponse.toJSON(message.finalizeCheckpointResponse);
    }
    if (message.error !== undefined) {
      obj.error = ControlError.toJSON(message.error);
    }
    if (message.emptyReturn !== undefined) {
      obj.emptyReturn = EmptyReturn.toJSON(message.emptyReturn);
    }
    if (message.stringResponse !== undefined) {
      obj.stringResponse = StringResponse.toJSON(message.stringResponse);
    }
    if (message.intResponse !== undefined) {
      obj.intResponse = IntResponse.toJSON(message.intResponse);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ControlReturn>, I>>(base?: I): ControlReturn {
    return ControlReturn.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ControlReturn>, I>>(object: I): ControlReturn {
    const message = createBaseControlReturn();
    message.retrieveWorkflowStateResponse =
      (object.retrieveWorkflowStateResponse !== undefined && object.retrieveWorkflowStateResponse !== null)
        ? RetrieveWorkflowStateResponse.fromPartial(object.retrieveWorkflowStateResponse)
        : undefined;
    message.propagateChannelMarkerResponse =
      (object.propagateChannelMarkerResponse !== undefined && object.propagateChannelMarkerResponse !== null)
        ? PropagateChannelMarkerResponse.fromPartial(object.propagateChannelMarkerResponse)
        : undefined;
    message.takeGlobalCheckpointResponse =
      (object.takeGlobalCheckpointResponse !== undefined && object.takeGlobalCheckpointResponse !== null)
        ? TakeGlobalCheckpointResponse.fromPartial(object.takeGlobalCheckpointResponse)
        : undefined;
    message.evaluatePythonExpressionResponse =
      (object.evaluatePythonExpressionResponse !== undefined && object.evaluatePythonExpressionResponse !== null)
        ? EvaluatePythonExpressionResponse.fromPartial(object.evaluatePythonExpressionResponse)
        : undefined;
    message.startWorkflowResponse =
      (object.startWorkflowResponse !== undefined && object.startWorkflowResponse !== null)
        ? StartWorkflowResponse.fromPartial(object.startWorkflowResponse)
        : undefined;
    message.workerStateResponse = (object.workerStateResponse !== undefined && object.workerStateResponse !== null)
      ? WorkerStateResponse.fromPartial(object.workerStateResponse)
      : undefined;
    message.workerMetricsResponse =
      (object.workerMetricsResponse !== undefined && object.workerMetricsResponse !== null)
        ? WorkerMetricsResponse.fromPartial(object.workerMetricsResponse)
        : undefined;
    message.finalizeCheckpointResponse =
      (object.finalizeCheckpointResponse !== undefined && object.finalizeCheckpointResponse !== null)
        ? FinalizeCheckpointResponse.fromPartial(object.finalizeCheckpointResponse)
        : undefined;
    message.error = (object.error !== undefined && object.error !== null)
      ? ControlError.fromPartial(object.error)
      : undefined;
    message.emptyReturn = (object.emptyReturn !== undefined && object.emptyReturn !== null)
      ? EmptyReturn.fromPartial(object.emptyReturn)
      : undefined;
    message.stringResponse = (object.stringResponse !== undefined && object.stringResponse !== null)
      ? StringResponse.fromPartial(object.stringResponse)
      : undefined;
    message.intResponse = (object.intResponse !== undefined && object.intResponse !== null)
      ? IntResponse.fromPartial(object.intResponse)
      : undefined;
    return message;
  },
};

function createBaseEmptyReturn(): EmptyReturn {
  return {};
}

export const EmptyReturn: MessageFns<EmptyReturn> = {
  encode(_: EmptyReturn, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EmptyReturn {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEmptyReturn();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): EmptyReturn {
    return {};
  },

  toJSON(_: EmptyReturn): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<EmptyReturn>, I>>(base?: I): EmptyReturn {
    return EmptyReturn.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EmptyReturn>, I>>(_: I): EmptyReturn {
    const message = createBaseEmptyReturn();
    return message;
  },
};

function createBaseControlError(): ControlError {
  return { errorMessage: "", errorDetails: "", stackTrace: "", language: 0 };
}

export const ControlError: MessageFns<ControlError> = {
  encode(message: ControlError, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.errorMessage !== "") {
      writer.uint32(10).string(message.errorMessage);
    }
    if (message.errorDetails !== "") {
      writer.uint32(18).string(message.errorDetails);
    }
    if (message.stackTrace !== "") {
      writer.uint32(26).string(message.stackTrace);
    }
    if (message.language !== 0) {
      writer.uint32(32).int32(message.language);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ControlError {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseControlError();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.errorDetails = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.stackTrace = reader.string();
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.language = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ControlError {
    return {
      errorMessage: isSet(object.errorMessage) ? globalThis.String(object.errorMessage) : "",
      errorDetails: isSet(object.errorDetails) ? globalThis.String(object.errorDetails) : "",
      stackTrace: isSet(object.stackTrace) ? globalThis.String(object.stackTrace) : "",
      language: isSet(object.language) ? errorLanguageFromJSON(object.language) : 0,
    };
  },

  toJSON(message: ControlError): unknown {
    const obj: any = {};
    if (message.errorMessage !== "") {
      obj.errorMessage = message.errorMessage;
    }
    if (message.errorDetails !== "") {
      obj.errorDetails = message.errorDetails;
    }
    if (message.stackTrace !== "") {
      obj.stackTrace = message.stackTrace;
    }
    if (message.language !== 0) {
      obj.language = errorLanguageToJSON(message.language);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ControlError>, I>>(base?: I): ControlError {
    return ControlError.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ControlError>, I>>(object: I): ControlError {
    const message = createBaseControlError();
    message.errorMessage = object.errorMessage ?? "";
    message.errorDetails = object.errorDetails ?? "";
    message.stackTrace = object.stackTrace ?? "";
    message.language = object.language ?? 0;
    return message;
  },
};

function createBaseReturnInvocation(): ReturnInvocation {
  return { commandId: 0, returnValue: undefined };
}

export const ReturnInvocation: MessageFns<ReturnInvocation> = {
  encode(message: ReturnInvocation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.commandId !== 0) {
      writer.uint32(8).int64(message.commandId);
    }
    if (message.returnValue !== undefined) {
      ControlReturn.encode(message.returnValue, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReturnInvocation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReturnInvocation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.commandId = longToNumber(reader.int64());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.returnValue = ControlReturn.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReturnInvocation {
    return {
      commandId: isSet(object.commandId) ? globalThis.Number(object.commandId) : 0,
      returnValue: isSet(object.returnValue) ? ControlReturn.fromJSON(object.returnValue) : undefined,
    };
  },

  toJSON(message: ReturnInvocation): unknown {
    const obj: any = {};
    if (message.commandId !== 0) {
      obj.commandId = Math.round(message.commandId);
    }
    if (message.returnValue !== undefined) {
      obj.returnValue = ControlReturn.toJSON(message.returnValue);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ReturnInvocation>, I>>(base?: I): ReturnInvocation {
    return ReturnInvocation.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ReturnInvocation>, I>>(object: I): ReturnInvocation {
    const message = createBaseReturnInvocation();
    message.commandId = object.commandId ?? 0;
    message.returnValue = (object.returnValue !== undefined && object.returnValue !== null)
      ? ControlReturn.fromPartial(object.returnValue)
      : undefined;
    return message;
  },
};

function createBaseStringResponse(): StringResponse {
  return { value: "" };
}

export const StringResponse: MessageFns<StringResponse> = {
  encode(message: StringResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.value !== "") {
      writer.uint32(10).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StringResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStringResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StringResponse {
    return { value: isSet(object.value) ? globalThis.String(object.value) : "" };
  },

  toJSON(message: StringResponse): unknown {
    const obj: any = {};
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StringResponse>, I>>(base?: I): StringResponse {
    return StringResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StringResponse>, I>>(object: I): StringResponse {
    const message = createBaseStringResponse();
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseIntResponse(): IntResponse {
  return { value: 0 };
}

export const IntResponse: MessageFns<IntResponse> = {
  encode(message: IntResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.value !== 0) {
      writer.uint32(8).int32(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): IntResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseIntResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.value = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): IntResponse {
    return { value: isSet(object.value) ? globalThis.Number(object.value) : 0 };
  },

  toJSON(message: IntResponse): unknown {
    const obj: any = {};
    if (message.value !== 0) {
      obj.value = Math.round(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<IntResponse>, I>>(base?: I): IntResponse {
    return IntResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<IntResponse>, I>>(object: I): IntResponse {
    const message = createBaseIntResponse();
    message.value = object.value ?? 0;
    return message;
  },
};

function createBaseRetrieveWorkflowStateResponse(): RetrieveWorkflowStateResponse {
  return { state: {} };
}

export const RetrieveWorkflowStateResponse: MessageFns<RetrieveWorkflowStateResponse> = {
  encode(message: RetrieveWorkflowStateResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    Object.entries(message.state).forEach(([key, value]) => {
      RetrieveWorkflowStateResponse_StateEntry.encode({ key: key as any, value }, writer.uint32(10).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RetrieveWorkflowStateResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRetrieveWorkflowStateResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          const entry1 = RetrieveWorkflowStateResponse_StateEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.state[entry1.key] = entry1.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RetrieveWorkflowStateResponse {
    return {
      state: isObject(object.state)
        ? Object.entries(object.state).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: RetrieveWorkflowStateResponse): unknown {
    const obj: any = {};
    if (message.state) {
      const entries = Object.entries(message.state);
      if (entries.length > 0) {
        obj.state = {};
        entries.forEach(([k, v]) => {
          obj.state[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RetrieveWorkflowStateResponse>, I>>(base?: I): RetrieveWorkflowStateResponse {
    return RetrieveWorkflowStateResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RetrieveWorkflowStateResponse>, I>>(
    object: I,
  ): RetrieveWorkflowStateResponse {
    const message = createBaseRetrieveWorkflowStateResponse();
    message.state = Object.entries(object.state ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseRetrieveWorkflowStateResponse_StateEntry(): RetrieveWorkflowStateResponse_StateEntry {
  return { key: "", value: "" };
}

export const RetrieveWorkflowStateResponse_StateEntry: MessageFns<RetrieveWorkflowStateResponse_StateEntry> = {
  encode(message: RetrieveWorkflowStateResponse_StateEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RetrieveWorkflowStateResponse_StateEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRetrieveWorkflowStateResponse_StateEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RetrieveWorkflowStateResponse_StateEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: RetrieveWorkflowStateResponse_StateEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RetrieveWorkflowStateResponse_StateEntry>, I>>(
    base?: I,
  ): RetrieveWorkflowStateResponse_StateEntry {
    return RetrieveWorkflowStateResponse_StateEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RetrieveWorkflowStateResponse_StateEntry>, I>>(
    object: I,
  ): RetrieveWorkflowStateResponse_StateEntry {
    const message = createBaseRetrieveWorkflowStateResponse_StateEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseFinalizeCheckpointResponse(): FinalizeCheckpointResponse {
  return { size: 0 };
}

export const FinalizeCheckpointResponse: MessageFns<FinalizeCheckpointResponse> = {
  encode(message: FinalizeCheckpointResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.size !== 0) {
      writer.uint32(8).int64(message.size);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FinalizeCheckpointResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFinalizeCheckpointResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.size = longToNumber(reader.int64());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FinalizeCheckpointResponse {
    return { size: isSet(object.size) ? globalThis.Number(object.size) : 0 };
  },

  toJSON(message: FinalizeCheckpointResponse): unknown {
    const obj: any = {};
    if (message.size !== 0) {
      obj.size = Math.round(message.size);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FinalizeCheckpointResponse>, I>>(base?: I): FinalizeCheckpointResponse {
    return FinalizeCheckpointResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FinalizeCheckpointResponse>, I>>(object: I): FinalizeCheckpointResponse {
    const message = createBaseFinalizeCheckpointResponse();
    message.size = object.size ?? 0;
    return message;
  },
};

function createBasePropagateChannelMarkerResponse(): PropagateChannelMarkerResponse {
  return { returns: {} };
}

export const PropagateChannelMarkerResponse: MessageFns<PropagateChannelMarkerResponse> = {
  encode(message: PropagateChannelMarkerResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    Object.entries(message.returns).forEach(([key, value]) => {
      PropagateChannelMarkerResponse_ReturnsEntry.encode({ key: key as any, value }, writer.uint32(10).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PropagateChannelMarkerResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePropagateChannelMarkerResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          const entry1 = PropagateChannelMarkerResponse_ReturnsEntry.decode(reader, reader.uint32());
          if (entry1.value !== undefined) {
            message.returns[entry1.key] = entry1.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PropagateChannelMarkerResponse {
    return {
      returns: isObject(object.returns)
        ? Object.entries(object.returns).reduce<{ [key: string]: ControlReturn }>((acc, [key, value]) => {
          acc[key] = ControlReturn.fromJSON(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: PropagateChannelMarkerResponse): unknown {
    const obj: any = {};
    if (message.returns) {
      const entries = Object.entries(message.returns);
      if (entries.length > 0) {
        obj.returns = {};
        entries.forEach(([k, v]) => {
          obj.returns[k] = ControlReturn.toJSON(v);
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PropagateChannelMarkerResponse>, I>>(base?: I): PropagateChannelMarkerResponse {
    return PropagateChannelMarkerResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PropagateChannelMarkerResponse>, I>>(
    object: I,
  ): PropagateChannelMarkerResponse {
    const message = createBasePropagateChannelMarkerResponse();
    message.returns = Object.entries(object.returns ?? {}).reduce<{ [key: string]: ControlReturn }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = ControlReturn.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBasePropagateChannelMarkerResponse_ReturnsEntry(): PropagateChannelMarkerResponse_ReturnsEntry {
  return { key: "", value: undefined };
}

export const PropagateChannelMarkerResponse_ReturnsEntry: MessageFns<PropagateChannelMarkerResponse_ReturnsEntry> = {
  encode(
    message: PropagateChannelMarkerResponse_ReturnsEntry,
    writer: BinaryWriter = new BinaryWriter(),
  ): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      ControlReturn.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PropagateChannelMarkerResponse_ReturnsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePropagateChannelMarkerResponse_ReturnsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = ControlReturn.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PropagateChannelMarkerResponse_ReturnsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? ControlReturn.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: PropagateChannelMarkerResponse_ReturnsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = ControlReturn.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PropagateChannelMarkerResponse_ReturnsEntry>, I>>(
    base?: I,
  ): PropagateChannelMarkerResponse_ReturnsEntry {
    return PropagateChannelMarkerResponse_ReturnsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PropagateChannelMarkerResponse_ReturnsEntry>, I>>(
    object: I,
  ): PropagateChannelMarkerResponse_ReturnsEntry {
    const message = createBasePropagateChannelMarkerResponse_ReturnsEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? ControlReturn.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBaseTakeGlobalCheckpointResponse(): TakeGlobalCheckpointResponse {
  return { totalSize: 0 };
}

export const TakeGlobalCheckpointResponse: MessageFns<TakeGlobalCheckpointResponse> = {
  encode(message: TakeGlobalCheckpointResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.totalSize !== 0) {
      writer.uint32(8).int64(message.totalSize);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TakeGlobalCheckpointResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTakeGlobalCheckpointResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.totalSize = longToNumber(reader.int64());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TakeGlobalCheckpointResponse {
    return { totalSize: isSet(object.totalSize) ? globalThis.Number(object.totalSize) : 0 };
  },

  toJSON(message: TakeGlobalCheckpointResponse): unknown {
    const obj: any = {};
    if (message.totalSize !== 0) {
      obj.totalSize = Math.round(message.totalSize);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TakeGlobalCheckpointResponse>, I>>(base?: I): TakeGlobalCheckpointResponse {
    return TakeGlobalCheckpointResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TakeGlobalCheckpointResponse>, I>>(object: I): TakeGlobalCheckpointResponse {
    const message = createBaseTakeGlobalCheckpointResponse();
    message.totalSize = object.totalSize ?? 0;
    return message;
  },
};

function createBaseTypedValue(): TypedValue {
  return { expression: "", valueRef: "", valueStr: "", valueType: "", expandable: false };
}

export const TypedValue: MessageFns<TypedValue> = {
  encode(message: TypedValue, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.expression !== "") {
      writer.uint32(10).string(message.expression);
    }
    if (message.valueRef !== "") {
      writer.uint32(18).string(message.valueRef);
    }
    if (message.valueStr !== "") {
      writer.uint32(26).string(message.valueStr);
    }
    if (message.valueType !== "") {
      writer.uint32(34).string(message.valueType);
    }
    if (message.expandable !== false) {
      writer.uint32(40).bool(message.expandable);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TypedValue {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTypedValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.expression = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.valueRef = reader.string();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.valueStr = reader.string();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.valueType = reader.string();
          continue;
        case 5:
          if (tag !== 40) {
            break;
          }

          message.expandable = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TypedValue {
    return {
      expression: isSet(object.expression) ? globalThis.String(object.expression) : "",
      valueRef: isSet(object.valueRef) ? globalThis.String(object.valueRef) : "",
      valueStr: isSet(object.valueStr) ? globalThis.String(object.valueStr) : "",
      valueType: isSet(object.valueType) ? globalThis.String(object.valueType) : "",
      expandable: isSet(object.expandable) ? globalThis.Boolean(object.expandable) : false,
    };
  },

  toJSON(message: TypedValue): unknown {
    const obj: any = {};
    if (message.expression !== "") {
      obj.expression = message.expression;
    }
    if (message.valueRef !== "") {
      obj.valueRef = message.valueRef;
    }
    if (message.valueStr !== "") {
      obj.valueStr = message.valueStr;
    }
    if (message.valueType !== "") {
      obj.valueType = message.valueType;
    }
    if (message.expandable !== false) {
      obj.expandable = message.expandable;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TypedValue>, I>>(base?: I): TypedValue {
    return TypedValue.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TypedValue>, I>>(object: I): TypedValue {
    const message = createBaseTypedValue();
    message.expression = object.expression ?? "";
    message.valueRef = object.valueRef ?? "";
    message.valueStr = object.valueStr ?? "";
    message.valueType = object.valueType ?? "";
    message.expandable = object.expandable ?? false;
    return message;
  },
};

function createBaseEvaluatedValue(): EvaluatedValue {
  return { value: undefined, attributes: [] };
}

export const EvaluatedValue: MessageFns<EvaluatedValue> = {
  encode(message: EvaluatedValue, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.value !== undefined) {
      TypedValue.encode(message.value, writer.uint32(10).fork()).join();
    }
    for (const v of message.attributes) {
      TypedValue.encode(v!, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EvaluatedValue {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEvaluatedValue();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.value = TypedValue.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.attributes.push(TypedValue.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EvaluatedValue {
    return {
      value: isSet(object.value) ? TypedValue.fromJSON(object.value) : undefined,
      attributes: globalThis.Array.isArray(object?.attributes)
        ? object.attributes.map((e: any) => TypedValue.fromJSON(e))
        : [],
    };
  },

  toJSON(message: EvaluatedValue): unknown {
    const obj: any = {};
    if (message.value !== undefined) {
      obj.value = TypedValue.toJSON(message.value);
    }
    if (message.attributes?.length) {
      obj.attributes = message.attributes.map((e) => TypedValue.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EvaluatedValue>, I>>(base?: I): EvaluatedValue {
    return EvaluatedValue.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EvaluatedValue>, I>>(object: I): EvaluatedValue {
    const message = createBaseEvaluatedValue();
    message.value = (object.value !== undefined && object.value !== null)
      ? TypedValue.fromPartial(object.value)
      : undefined;
    message.attributes = object.attributes?.map((e) => TypedValue.fromPartial(e)) || [];
    return message;
  },
};

function createBaseEvaluatePythonExpressionResponse(): EvaluatePythonExpressionResponse {
  return { values: [] };
}

export const EvaluatePythonExpressionResponse: MessageFns<EvaluatePythonExpressionResponse> = {
  encode(message: EvaluatePythonExpressionResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.values) {
      EvaluatedValue.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EvaluatePythonExpressionResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEvaluatePythonExpressionResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.values.push(EvaluatedValue.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EvaluatePythonExpressionResponse {
    return {
      values: globalThis.Array.isArray(object?.values) ? object.values.map((e: any) => EvaluatedValue.fromJSON(e)) : [],
    };
  },

  toJSON(message: EvaluatePythonExpressionResponse): unknown {
    const obj: any = {};
    if (message.values?.length) {
      obj.values = message.values.map((e) => EvaluatedValue.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EvaluatePythonExpressionResponse>, I>>(
    base?: I,
  ): EvaluatePythonExpressionResponse {
    return EvaluatePythonExpressionResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EvaluatePythonExpressionResponse>, I>>(
    object: I,
  ): EvaluatePythonExpressionResponse {
    const message = createBaseEvaluatePythonExpressionResponse();
    message.values = object.values?.map((e) => EvaluatedValue.fromPartial(e)) || [];
    return message;
  },
};

function createBaseStartWorkflowResponse(): StartWorkflowResponse {
  return { workflowState: 0 };
}

export const StartWorkflowResponse: MessageFns<StartWorkflowResponse> = {
  encode(message: StartWorkflowResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.workflowState !== 0) {
      writer.uint32(8).int32(message.workflowState);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): StartWorkflowResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseStartWorkflowResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.workflowState = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): StartWorkflowResponse {
    return { workflowState: isSet(object.workflowState) ? workflowAggregatedStateFromJSON(object.workflowState) : 0 };
  },

  toJSON(message: StartWorkflowResponse): unknown {
    const obj: any = {};
    if (message.workflowState !== 0) {
      obj.workflowState = workflowAggregatedStateToJSON(message.workflowState);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<StartWorkflowResponse>, I>>(base?: I): StartWorkflowResponse {
    return StartWorkflowResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<StartWorkflowResponse>, I>>(object: I): StartWorkflowResponse {
    const message = createBaseStartWorkflowResponse();
    message.workflowState = object.workflowState ?? 0;
    return message;
  },
};

function createBaseWorkerStateResponse(): WorkerStateResponse {
  return { state: 0 };
}

export const WorkerStateResponse: MessageFns<WorkerStateResponse> = {
  encode(message: WorkerStateResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.state !== 0) {
      writer.uint32(8).int32(message.state);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WorkerStateResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWorkerStateResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WorkerStateResponse {
    return { state: isSet(object.state) ? workerStateFromJSON(object.state) : 0 };
  },

  toJSON(message: WorkerStateResponse): unknown {
    const obj: any = {};
    if (message.state !== 0) {
      obj.state = workerStateToJSON(message.state);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WorkerStateResponse>, I>>(base?: I): WorkerStateResponse {
    return WorkerStateResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WorkerStateResponse>, I>>(object: I): WorkerStateResponse {
    const message = createBaseWorkerStateResponse();
    message.state = object.state ?? 0;
    return message;
  },
};

function createBaseWorkerMetricsResponse(): WorkerMetricsResponse {
  return { metrics: undefined };
}

export const WorkerMetricsResponse: MessageFns<WorkerMetricsResponse> = {
  encode(message: WorkerMetricsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.metrics !== undefined) {
      WorkerMetrics.encode(message.metrics, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WorkerMetricsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWorkerMetricsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.metrics = WorkerMetrics.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WorkerMetricsResponse {
    return { metrics: isSet(object.metrics) ? WorkerMetrics.fromJSON(object.metrics) : undefined };
  },

  toJSON(message: WorkerMetricsResponse): unknown {
    const obj: any = {};
    if (message.metrics !== undefined) {
      obj.metrics = WorkerMetrics.toJSON(message.metrics);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WorkerMetricsResponse>, I>>(base?: I): WorkerMetricsResponse {
    return WorkerMetricsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WorkerMetricsResponse>, I>>(object: I): WorkerMetricsResponse {
    const message = createBaseWorkerMetricsResponse();
    message.metrics = (object.metrics !== undefined && object.metrics !== null)
      ? WorkerMetrics.fromPartial(object.metrics)
      : undefined;
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
