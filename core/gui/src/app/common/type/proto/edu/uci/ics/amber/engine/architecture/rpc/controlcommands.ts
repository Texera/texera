// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.0
//   protoc               v5.28.3
// source: edu/uci/ics/amber/engine/architecture/rpc/controlcommands.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import { Any } from "../../../../../../../google/protobuf/any";
import { Timestamp } from "../../../../../../../google/protobuf/timestamp";
import {
  ActorVirtualIdentity,
  ChannelIdentity,
  ChannelMarkerIdentity,
  PhysicalOpIdentity,
} from "../../common/virtualidentity";
import { PhysicalLink, PortIdentity } from "../../common/workflow";
import { Partitioning } from "../sendsemantics/partitionings";
import { WorkerState, workerStateFromJSON, workerStateToJSON } from "../worker/statistics";

export const protobufPackage = "edu.uci.ics.amber.engine.architecture.rpc";

/** Enum for ChannelMarkerType */
export enum ChannelMarkerType {
  REQUIRE_ALIGNMENT = 0,
  NO_ALIGNMENT = 1,
  UNRECOGNIZED = -1,
}

export function channelMarkerTypeFromJSON(object: any): ChannelMarkerType {
  switch (object) {
    case 0:
    case "REQUIRE_ALIGNMENT":
      return ChannelMarkerType.REQUIRE_ALIGNMENT;
    case 1:
    case "NO_ALIGNMENT":
      return ChannelMarkerType.NO_ALIGNMENT;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ChannelMarkerType.UNRECOGNIZED;
  }
}

export function channelMarkerTypeToJSON(object: ChannelMarkerType): string {
  switch (object) {
    case ChannelMarkerType.REQUIRE_ALIGNMENT:
      return "REQUIRE_ALIGNMENT";
    case ChannelMarkerType.NO_ALIGNMENT:
      return "NO_ALIGNMENT";
    case ChannelMarkerType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export enum ConsoleMessageType {
  PRINT = 0,
  ERROR = 1,
  COMMAND = 2,
  DEBUGGER = 3,
  UNRECOGNIZED = -1,
}

export function consoleMessageTypeFromJSON(object: any): ConsoleMessageType {
  switch (object) {
    case 0:
    case "PRINT":
      return ConsoleMessageType.PRINT;
    case 1:
    case "ERROR":
      return ConsoleMessageType.ERROR;
    case 2:
    case "COMMAND":
      return ConsoleMessageType.COMMAND;
    case 3:
    case "DEBUGGER":
      return ConsoleMessageType.DEBUGGER;
    case -1:
    case "UNRECOGNIZED":
    default:
      return ConsoleMessageType.UNRECOGNIZED;
  }
}

export function consoleMessageTypeToJSON(object: ConsoleMessageType): string {
  switch (object) {
    case ConsoleMessageType.PRINT:
      return "PRINT";
    case ConsoleMessageType.ERROR:
      return "ERROR";
    case ConsoleMessageType.COMMAND:
      return "COMMAND";
    case ConsoleMessageType.DEBUGGER:
      return "DEBUGGER";
    case ConsoleMessageType.UNRECOGNIZED:
    default:
      return "UNRECOGNIZED";
  }
}

export interface ControlRequest {
  /** request for controller */
  propagateChannelMarkerRequest?: PropagateChannelMarkerRequest | undefined;
  takeGlobalCheckpointRequest?: TakeGlobalCheckpointRequest | undefined;
  debugCommandRequest?: DebugCommandRequest | undefined;
  evaluatePythonExpressionRequest?: EvaluatePythonExpressionRequest | undefined;
  modifyLogicRequest?: ModifyLogicRequest | undefined;
  retryWorkflowRequest?: RetryWorkflowRequest | undefined;
  consoleMessageTriggeredRequest?: ConsoleMessageTriggeredRequest | undefined;
  portCompletedRequest?: PortCompletedRequest | undefined;
  workerStateUpdatedRequest?: WorkerStateUpdatedRequest | undefined;
  linkWorkersRequest?:
    | LinkWorkersRequest
    | undefined;
  /** request for worker */
  addInputChannelRequest?: AddInputChannelRequest | undefined;
  addPartitioningRequest?: AddPartitioningRequest | undefined;
  assignPortRequest?: AssignPortRequest | undefined;
  finalizeCheckpointRequest?: FinalizeCheckpointRequest | undefined;
  initializeExecutorRequest?: InitializeExecutorRequest | undefined;
  updateExecutorRequest?: UpdateExecutorRequest | undefined;
  emptyRequest?: EmptyRequest | undefined;
  prepareCheckpointRequest?: PrepareCheckpointRequest | undefined;
  queryStatisticsRequest?:
    | QueryStatisticsRequest
    | undefined;
  /** request for testing */
  ping?: Ping | undefined;
  pong?: Pong | undefined;
  nested?: Nested | undefined;
  pass?: Pass | undefined;
  errorCommand?: ErrorCommand | undefined;
  recursion?: Recursion | undefined;
  collect?: Collect | undefined;
  generateNumber?: GenerateNumber | undefined;
  multiCall?: MultiCall | undefined;
  chain?: Chain | undefined;
}

export interface EmptyRequest {
}

export interface AsyncRPCContext {
  sender: ActorVirtualIdentity | undefined;
  receiver: ActorVirtualIdentity | undefined;
}

export interface ControlInvocation {
  methodName: string;
  command: ControlRequest | undefined;
  context: AsyncRPCContext | undefined;
  commandId: number;
}

/** Message for ChannelMarkerPayload */
export interface ChannelMarkerPayload {
  id: ChannelMarkerIdentity | undefined;
  markerType: ChannelMarkerType;
  scope: ChannelIdentity[];
  commandMapping: { [key: string]: ControlInvocation };
}

export interface ChannelMarkerPayload_CommandMappingEntry {
  key: string;
  value: ControlInvocation | undefined;
}

export interface PropagateChannelMarkerRequest {
  sourceOpToStartProp: PhysicalOpIdentity[];
  id: ChannelMarkerIdentity | undefined;
  markerType: ChannelMarkerType;
  scope: PhysicalOpIdentity[];
  targetOps: PhysicalOpIdentity[];
  markerCommand: ControlRequest | undefined;
  markerMethodName: string;
}

export interface TakeGlobalCheckpointRequest {
  estimationOnly: boolean;
  checkpointId: ChannelMarkerIdentity | undefined;
  destination: string;
}

export interface WorkflowReconfigureRequest {
  reconfiguration: ModifyLogicRequest | undefined;
  reconfigurationId: string;
}

export interface DebugCommandRequest {
  workerId: string;
  cmd: string;
}

export interface EvaluatePythonExpressionRequest {
  expression: string;
  operatorId: string;
}

export interface ModifyLogicRequest {
  updateRequest: UpdateExecutorRequest[];
}

export interface RetryWorkflowRequest {
  workers: ActorVirtualIdentity[];
}

export interface ConsoleMessage {
  workerId: string;
  timestamp: Date | undefined;
  msgType: ConsoleMessageType;
  source: string;
  title: string;
  message: string;
}

export interface ConsoleMessageTriggeredRequest {
  consoleMessage: ConsoleMessage | undefined;
}

export interface PortCompletedRequest {
  portId: PortIdentity | undefined;
  input: boolean;
}

export interface WorkerStateUpdatedRequest {
  state: WorkerState;
}

export interface LinkWorkersRequest {
  link: PhysicalLink | undefined;
}

/** Ping message */
export interface Ping {
  i: number;
  end: number;
  to: ActorVirtualIdentity | undefined;
}

/** Pong message */
export interface Pong {
  i: number;
  end: number;
  to: ActorVirtualIdentity | undefined;
}

/** Pass message */
export interface Pass {
  value: string;
}

/** Nested message */
export interface Nested {
  k: number;
}

/** MultiCall message */
export interface MultiCall {
  seq: ActorVirtualIdentity[];
}

/** ErrorCommand message */
export interface ErrorCommand {
}

/** Collect message */
export interface Collect {
  workers: ActorVirtualIdentity[];
}

/** GenerateNumber message */
export interface GenerateNumber {
}

/** Chain message */
export interface Chain {
  nexts: ActorVirtualIdentity[];
}

/** Recursion message */
export interface Recursion {
  i: number;
}

/** Messages for the commands */
export interface AddInputChannelRequest {
  channelId: ChannelIdentity | undefined;
  portId: PortIdentity | undefined;
}

export interface AddPartitioningRequest {
  tag: PhysicalLink | undefined;
  partitioning: Partitioning | undefined;
}

export interface AssignPortRequest {
  portId: PortIdentity | undefined;
  input: boolean;
  schema: { [key: string]: string };
}

export interface AssignPortRequest_SchemaEntry {
  key: string;
  value: string;
}

export interface FinalizeCheckpointRequest {
  checkpointId: ChannelMarkerIdentity | undefined;
  writeTo: string;
}

export interface InitializeExecutorRequest {
  totalWorkerCount: number;
  opExecInitInfo: Any | undefined;
  isSource: boolean;
  language: string;
}

export interface UpdateExecutorRequest {
  targetOpId: PhysicalOpIdentity | undefined;
  newExecutor: Any | undefined;
  stateTransferFunc: Any | undefined;
}

export interface PrepareCheckpointRequest {
  checkpointId: ChannelMarkerIdentity | undefined;
  estimationOnly: boolean;
}

export interface QueryStatisticsRequest {
  filterByWorkers: ActorVirtualIdentity[];
}

function createBaseControlRequest(): ControlRequest {
  return {
    propagateChannelMarkerRequest: undefined,
    takeGlobalCheckpointRequest: undefined,
    debugCommandRequest: undefined,
    evaluatePythonExpressionRequest: undefined,
    modifyLogicRequest: undefined,
    retryWorkflowRequest: undefined,
    consoleMessageTriggeredRequest: undefined,
    portCompletedRequest: undefined,
    workerStateUpdatedRequest: undefined,
    linkWorkersRequest: undefined,
    addInputChannelRequest: undefined,
    addPartitioningRequest: undefined,
    assignPortRequest: undefined,
    finalizeCheckpointRequest: undefined,
    initializeExecutorRequest: undefined,
    updateExecutorRequest: undefined,
    emptyRequest: undefined,
    prepareCheckpointRequest: undefined,
    queryStatisticsRequest: undefined,
    ping: undefined,
    pong: undefined,
    nested: undefined,
    pass: undefined,
    errorCommand: undefined,
    recursion: undefined,
    collect: undefined,
    generateNumber: undefined,
    multiCall: undefined,
    chain: undefined,
  };
}

export const ControlRequest: MessageFns<ControlRequest> = {
  encode(message: ControlRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.propagateChannelMarkerRequest !== undefined) {
      PropagateChannelMarkerRequest.encode(message.propagateChannelMarkerRequest, writer.uint32(10).fork()).join();
    }
    if (message.takeGlobalCheckpointRequest !== undefined) {
      TakeGlobalCheckpointRequest.encode(message.takeGlobalCheckpointRequest, writer.uint32(18).fork()).join();
    }
    if (message.debugCommandRequest !== undefined) {
      DebugCommandRequest.encode(message.debugCommandRequest, writer.uint32(26).fork()).join();
    }
    if (message.evaluatePythonExpressionRequest !== undefined) {
      EvaluatePythonExpressionRequest.encode(message.evaluatePythonExpressionRequest, writer.uint32(34).fork()).join();
    }
    if (message.modifyLogicRequest !== undefined) {
      ModifyLogicRequest.encode(message.modifyLogicRequest, writer.uint32(42).fork()).join();
    }
    if (message.retryWorkflowRequest !== undefined) {
      RetryWorkflowRequest.encode(message.retryWorkflowRequest, writer.uint32(50).fork()).join();
    }
    if (message.consoleMessageTriggeredRequest !== undefined) {
      ConsoleMessageTriggeredRequest.encode(message.consoleMessageTriggeredRequest, writer.uint32(66).fork()).join();
    }
    if (message.portCompletedRequest !== undefined) {
      PortCompletedRequest.encode(message.portCompletedRequest, writer.uint32(74).fork()).join();
    }
    if (message.workerStateUpdatedRequest !== undefined) {
      WorkerStateUpdatedRequest.encode(message.workerStateUpdatedRequest, writer.uint32(82).fork()).join();
    }
    if (message.linkWorkersRequest !== undefined) {
      LinkWorkersRequest.encode(message.linkWorkersRequest, writer.uint32(90).fork()).join();
    }
    if (message.addInputChannelRequest !== undefined) {
      AddInputChannelRequest.encode(message.addInputChannelRequest, writer.uint32(402).fork()).join();
    }
    if (message.addPartitioningRequest !== undefined) {
      AddPartitioningRequest.encode(message.addPartitioningRequest, writer.uint32(410).fork()).join();
    }
    if (message.assignPortRequest !== undefined) {
      AssignPortRequest.encode(message.assignPortRequest, writer.uint32(418).fork()).join();
    }
    if (message.finalizeCheckpointRequest !== undefined) {
      FinalizeCheckpointRequest.encode(message.finalizeCheckpointRequest, writer.uint32(426).fork()).join();
    }
    if (message.initializeExecutorRequest !== undefined) {
      InitializeExecutorRequest.encode(message.initializeExecutorRequest, writer.uint32(434).fork()).join();
    }
    if (message.updateExecutorRequest !== undefined) {
      UpdateExecutorRequest.encode(message.updateExecutorRequest, writer.uint32(442).fork()).join();
    }
    if (message.emptyRequest !== undefined) {
      EmptyRequest.encode(message.emptyRequest, writer.uint32(450).fork()).join();
    }
    if (message.prepareCheckpointRequest !== undefined) {
      PrepareCheckpointRequest.encode(message.prepareCheckpointRequest, writer.uint32(458).fork()).join();
    }
    if (message.queryStatisticsRequest !== undefined) {
      QueryStatisticsRequest.encode(message.queryStatisticsRequest, writer.uint32(466).fork()).join();
    }
    if (message.ping !== undefined) {
      Ping.encode(message.ping, writer.uint32(802).fork()).join();
    }
    if (message.pong !== undefined) {
      Pong.encode(message.pong, writer.uint32(810).fork()).join();
    }
    if (message.nested !== undefined) {
      Nested.encode(message.nested, writer.uint32(818).fork()).join();
    }
    if (message.pass !== undefined) {
      Pass.encode(message.pass, writer.uint32(826).fork()).join();
    }
    if (message.errorCommand !== undefined) {
      ErrorCommand.encode(message.errorCommand, writer.uint32(834).fork()).join();
    }
    if (message.recursion !== undefined) {
      Recursion.encode(message.recursion, writer.uint32(842).fork()).join();
    }
    if (message.collect !== undefined) {
      Collect.encode(message.collect, writer.uint32(850).fork()).join();
    }
    if (message.generateNumber !== undefined) {
      GenerateNumber.encode(message.generateNumber, writer.uint32(858).fork()).join();
    }
    if (message.multiCall !== undefined) {
      MultiCall.encode(message.multiCall, writer.uint32(866).fork()).join();
    }
    if (message.chain !== undefined) {
      Chain.encode(message.chain, writer.uint32(874).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ControlRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseControlRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.propagateChannelMarkerRequest = PropagateChannelMarkerRequest.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.takeGlobalCheckpointRequest = TakeGlobalCheckpointRequest.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.debugCommandRequest = DebugCommandRequest.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.evaluatePythonExpressionRequest = EvaluatePythonExpressionRequest.decode(reader, reader.uint32());
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.modifyLogicRequest = ModifyLogicRequest.decode(reader, reader.uint32());
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.retryWorkflowRequest = RetryWorkflowRequest.decode(reader, reader.uint32());
          continue;
        case 8:
          if (tag !== 66) {
            break;
          }

          message.consoleMessageTriggeredRequest = ConsoleMessageTriggeredRequest.decode(reader, reader.uint32());
          continue;
        case 9:
          if (tag !== 74) {
            break;
          }

          message.portCompletedRequest = PortCompletedRequest.decode(reader, reader.uint32());
          continue;
        case 10:
          if (tag !== 82) {
            break;
          }

          message.workerStateUpdatedRequest = WorkerStateUpdatedRequest.decode(reader, reader.uint32());
          continue;
        case 11:
          if (tag !== 90) {
            break;
          }

          message.linkWorkersRequest = LinkWorkersRequest.decode(reader, reader.uint32());
          continue;
        case 50:
          if (tag !== 402) {
            break;
          }

          message.addInputChannelRequest = AddInputChannelRequest.decode(reader, reader.uint32());
          continue;
        case 51:
          if (tag !== 410) {
            break;
          }

          message.addPartitioningRequest = AddPartitioningRequest.decode(reader, reader.uint32());
          continue;
        case 52:
          if (tag !== 418) {
            break;
          }

          message.assignPortRequest = AssignPortRequest.decode(reader, reader.uint32());
          continue;
        case 53:
          if (tag !== 426) {
            break;
          }

          message.finalizeCheckpointRequest = FinalizeCheckpointRequest.decode(reader, reader.uint32());
          continue;
        case 54:
          if (tag !== 434) {
            break;
          }

          message.initializeExecutorRequest = InitializeExecutorRequest.decode(reader, reader.uint32());
          continue;
        case 55:
          if (tag !== 442) {
            break;
          }

          message.updateExecutorRequest = UpdateExecutorRequest.decode(reader, reader.uint32());
          continue;
        case 56:
          if (tag !== 450) {
            break;
          }

          message.emptyRequest = EmptyRequest.decode(reader, reader.uint32());
          continue;
        case 57:
          if (tag !== 458) {
            break;
          }

          message.prepareCheckpointRequest = PrepareCheckpointRequest.decode(reader, reader.uint32());
          continue;
        case 58:
          if (tag !== 466) {
            break;
          }

          message.queryStatisticsRequest = QueryStatisticsRequest.decode(reader, reader.uint32());
          continue;
        case 100:
          if (tag !== 802) {
            break;
          }

          message.ping = Ping.decode(reader, reader.uint32());
          continue;
        case 101:
          if (tag !== 810) {
            break;
          }

          message.pong = Pong.decode(reader, reader.uint32());
          continue;
        case 102:
          if (tag !== 818) {
            break;
          }

          message.nested = Nested.decode(reader, reader.uint32());
          continue;
        case 103:
          if (tag !== 826) {
            break;
          }

          message.pass = Pass.decode(reader, reader.uint32());
          continue;
        case 104:
          if (tag !== 834) {
            break;
          }

          message.errorCommand = ErrorCommand.decode(reader, reader.uint32());
          continue;
        case 105:
          if (tag !== 842) {
            break;
          }

          message.recursion = Recursion.decode(reader, reader.uint32());
          continue;
        case 106:
          if (tag !== 850) {
            break;
          }

          message.collect = Collect.decode(reader, reader.uint32());
          continue;
        case 107:
          if (tag !== 858) {
            break;
          }

          message.generateNumber = GenerateNumber.decode(reader, reader.uint32());
          continue;
        case 108:
          if (tag !== 866) {
            break;
          }

          message.multiCall = MultiCall.decode(reader, reader.uint32());
          continue;
        case 109:
          if (tag !== 874) {
            break;
          }

          message.chain = Chain.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ControlRequest {
    return {
      propagateChannelMarkerRequest: isSet(object.propagateChannelMarkerRequest)
        ? PropagateChannelMarkerRequest.fromJSON(object.propagateChannelMarkerRequest)
        : undefined,
      takeGlobalCheckpointRequest: isSet(object.takeGlobalCheckpointRequest)
        ? TakeGlobalCheckpointRequest.fromJSON(object.takeGlobalCheckpointRequest)
        : undefined,
      debugCommandRequest: isSet(object.debugCommandRequest)
        ? DebugCommandRequest.fromJSON(object.debugCommandRequest)
        : undefined,
      evaluatePythonExpressionRequest: isSet(object.evaluatePythonExpressionRequest)
        ? EvaluatePythonExpressionRequest.fromJSON(object.evaluatePythonExpressionRequest)
        : undefined,
      modifyLogicRequest: isSet(object.modifyLogicRequest)
        ? ModifyLogicRequest.fromJSON(object.modifyLogicRequest)
        : undefined,
      retryWorkflowRequest: isSet(object.retryWorkflowRequest)
        ? RetryWorkflowRequest.fromJSON(object.retryWorkflowRequest)
        : undefined,
      consoleMessageTriggeredRequest: isSet(object.consoleMessageTriggeredRequest)
        ? ConsoleMessageTriggeredRequest.fromJSON(object.consoleMessageTriggeredRequest)
        : undefined,
      portCompletedRequest: isSet(object.portCompletedRequest)
        ? PortCompletedRequest.fromJSON(object.portCompletedRequest)
        : undefined,
      workerStateUpdatedRequest: isSet(object.workerStateUpdatedRequest)
        ? WorkerStateUpdatedRequest.fromJSON(object.workerStateUpdatedRequest)
        : undefined,
      linkWorkersRequest: isSet(object.linkWorkersRequest)
        ? LinkWorkersRequest.fromJSON(object.linkWorkersRequest)
        : undefined,
      addInputChannelRequest: isSet(object.addInputChannelRequest)
        ? AddInputChannelRequest.fromJSON(object.addInputChannelRequest)
        : undefined,
      addPartitioningRequest: isSet(object.addPartitioningRequest)
        ? AddPartitioningRequest.fromJSON(object.addPartitioningRequest)
        : undefined,
      assignPortRequest: isSet(object.assignPortRequest)
        ? AssignPortRequest.fromJSON(object.assignPortRequest)
        : undefined,
      finalizeCheckpointRequest: isSet(object.finalizeCheckpointRequest)
        ? FinalizeCheckpointRequest.fromJSON(object.finalizeCheckpointRequest)
        : undefined,
      initializeExecutorRequest: isSet(object.initializeExecutorRequest)
        ? InitializeExecutorRequest.fromJSON(object.initializeExecutorRequest)
        : undefined,
      updateExecutorRequest: isSet(object.updateExecutorRequest)
        ? UpdateExecutorRequest.fromJSON(object.updateExecutorRequest)
        : undefined,
      emptyRequest: isSet(object.emptyRequest) ? EmptyRequest.fromJSON(object.emptyRequest) : undefined,
      prepareCheckpointRequest: isSet(object.prepareCheckpointRequest)
        ? PrepareCheckpointRequest.fromJSON(object.prepareCheckpointRequest)
        : undefined,
      queryStatisticsRequest: isSet(object.queryStatisticsRequest)
        ? QueryStatisticsRequest.fromJSON(object.queryStatisticsRequest)
        : undefined,
      ping: isSet(object.ping) ? Ping.fromJSON(object.ping) : undefined,
      pong: isSet(object.pong) ? Pong.fromJSON(object.pong) : undefined,
      nested: isSet(object.nested) ? Nested.fromJSON(object.nested) : undefined,
      pass: isSet(object.pass) ? Pass.fromJSON(object.pass) : undefined,
      errorCommand: isSet(object.errorCommand) ? ErrorCommand.fromJSON(object.errorCommand) : undefined,
      recursion: isSet(object.recursion) ? Recursion.fromJSON(object.recursion) : undefined,
      collect: isSet(object.collect) ? Collect.fromJSON(object.collect) : undefined,
      generateNumber: isSet(object.generateNumber) ? GenerateNumber.fromJSON(object.generateNumber) : undefined,
      multiCall: isSet(object.multiCall) ? MultiCall.fromJSON(object.multiCall) : undefined,
      chain: isSet(object.chain) ? Chain.fromJSON(object.chain) : undefined,
    };
  },

  toJSON(message: ControlRequest): unknown {
    const obj: any = {};
    if (message.propagateChannelMarkerRequest !== undefined) {
      obj.propagateChannelMarkerRequest = PropagateChannelMarkerRequest.toJSON(message.propagateChannelMarkerRequest);
    }
    if (message.takeGlobalCheckpointRequest !== undefined) {
      obj.takeGlobalCheckpointRequest = TakeGlobalCheckpointRequest.toJSON(message.takeGlobalCheckpointRequest);
    }
    if (message.debugCommandRequest !== undefined) {
      obj.debugCommandRequest = DebugCommandRequest.toJSON(message.debugCommandRequest);
    }
    if (message.evaluatePythonExpressionRequest !== undefined) {
      obj.evaluatePythonExpressionRequest = EvaluatePythonExpressionRequest.toJSON(
        message.evaluatePythonExpressionRequest,
      );
    }
    if (message.modifyLogicRequest !== undefined) {
      obj.modifyLogicRequest = ModifyLogicRequest.toJSON(message.modifyLogicRequest);
    }
    if (message.retryWorkflowRequest !== undefined) {
      obj.retryWorkflowRequest = RetryWorkflowRequest.toJSON(message.retryWorkflowRequest);
    }
    if (message.consoleMessageTriggeredRequest !== undefined) {
      obj.consoleMessageTriggeredRequest = ConsoleMessageTriggeredRequest.toJSON(
        message.consoleMessageTriggeredRequest,
      );
    }
    if (message.portCompletedRequest !== undefined) {
      obj.portCompletedRequest = PortCompletedRequest.toJSON(message.portCompletedRequest);
    }
    if (message.workerStateUpdatedRequest !== undefined) {
      obj.workerStateUpdatedRequest = WorkerStateUpdatedRequest.toJSON(message.workerStateUpdatedRequest);
    }
    if (message.linkWorkersRequest !== undefined) {
      obj.linkWorkersRequest = LinkWorkersRequest.toJSON(message.linkWorkersRequest);
    }
    if (message.addInputChannelRequest !== undefined) {
      obj.addInputChannelRequest = AddInputChannelRequest.toJSON(message.addInputChannelRequest);
    }
    if (message.addPartitioningRequest !== undefined) {
      obj.addPartitioningRequest = AddPartitioningRequest.toJSON(message.addPartitioningRequest);
    }
    if (message.assignPortRequest !== undefined) {
      obj.assignPortRequest = AssignPortRequest.toJSON(message.assignPortRequest);
    }
    if (message.finalizeCheckpointRequest !== undefined) {
      obj.finalizeCheckpointRequest = FinalizeCheckpointRequest.toJSON(message.finalizeCheckpointRequest);
    }
    if (message.initializeExecutorRequest !== undefined) {
      obj.initializeExecutorRequest = InitializeExecutorRequest.toJSON(message.initializeExecutorRequest);
    }
    if (message.updateExecutorRequest !== undefined) {
      obj.updateExecutorRequest = UpdateExecutorRequest.toJSON(message.updateExecutorRequest);
    }
    if (message.emptyRequest !== undefined) {
      obj.emptyRequest = EmptyRequest.toJSON(message.emptyRequest);
    }
    if (message.prepareCheckpointRequest !== undefined) {
      obj.prepareCheckpointRequest = PrepareCheckpointRequest.toJSON(message.prepareCheckpointRequest);
    }
    if (message.queryStatisticsRequest !== undefined) {
      obj.queryStatisticsRequest = QueryStatisticsRequest.toJSON(message.queryStatisticsRequest);
    }
    if (message.ping !== undefined) {
      obj.ping = Ping.toJSON(message.ping);
    }
    if (message.pong !== undefined) {
      obj.pong = Pong.toJSON(message.pong);
    }
    if (message.nested !== undefined) {
      obj.nested = Nested.toJSON(message.nested);
    }
    if (message.pass !== undefined) {
      obj.pass = Pass.toJSON(message.pass);
    }
    if (message.errorCommand !== undefined) {
      obj.errorCommand = ErrorCommand.toJSON(message.errorCommand);
    }
    if (message.recursion !== undefined) {
      obj.recursion = Recursion.toJSON(message.recursion);
    }
    if (message.collect !== undefined) {
      obj.collect = Collect.toJSON(message.collect);
    }
    if (message.generateNumber !== undefined) {
      obj.generateNumber = GenerateNumber.toJSON(message.generateNumber);
    }
    if (message.multiCall !== undefined) {
      obj.multiCall = MultiCall.toJSON(message.multiCall);
    }
    if (message.chain !== undefined) {
      obj.chain = Chain.toJSON(message.chain);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ControlRequest>, I>>(base?: I): ControlRequest {
    return ControlRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ControlRequest>, I>>(object: I): ControlRequest {
    const message = createBaseControlRequest();
    message.propagateChannelMarkerRequest =
      (object.propagateChannelMarkerRequest !== undefined && object.propagateChannelMarkerRequest !== null)
        ? PropagateChannelMarkerRequest.fromPartial(object.propagateChannelMarkerRequest)
        : undefined;
    message.takeGlobalCheckpointRequest =
      (object.takeGlobalCheckpointRequest !== undefined && object.takeGlobalCheckpointRequest !== null)
        ? TakeGlobalCheckpointRequest.fromPartial(object.takeGlobalCheckpointRequest)
        : undefined;
    message.debugCommandRequest = (object.debugCommandRequest !== undefined && object.debugCommandRequest !== null)
      ? DebugCommandRequest.fromPartial(object.debugCommandRequest)
      : undefined;
    message.evaluatePythonExpressionRequest =
      (object.evaluatePythonExpressionRequest !== undefined && object.evaluatePythonExpressionRequest !== null)
        ? EvaluatePythonExpressionRequest.fromPartial(object.evaluatePythonExpressionRequest)
        : undefined;
    message.modifyLogicRequest = (object.modifyLogicRequest !== undefined && object.modifyLogicRequest !== null)
      ? ModifyLogicRequest.fromPartial(object.modifyLogicRequest)
      : undefined;
    message.retryWorkflowRequest = (object.retryWorkflowRequest !== undefined && object.retryWorkflowRequest !== null)
      ? RetryWorkflowRequest.fromPartial(object.retryWorkflowRequest)
      : undefined;
    message.consoleMessageTriggeredRequest =
      (object.consoleMessageTriggeredRequest !== undefined && object.consoleMessageTriggeredRequest !== null)
        ? ConsoleMessageTriggeredRequest.fromPartial(object.consoleMessageTriggeredRequest)
        : undefined;
    message.portCompletedRequest = (object.portCompletedRequest !== undefined && object.portCompletedRequest !== null)
      ? PortCompletedRequest.fromPartial(object.portCompletedRequest)
      : undefined;
    message.workerStateUpdatedRequest =
      (object.workerStateUpdatedRequest !== undefined && object.workerStateUpdatedRequest !== null)
        ? WorkerStateUpdatedRequest.fromPartial(object.workerStateUpdatedRequest)
        : undefined;
    message.linkWorkersRequest = (object.linkWorkersRequest !== undefined && object.linkWorkersRequest !== null)
      ? LinkWorkersRequest.fromPartial(object.linkWorkersRequest)
      : undefined;
    message.addInputChannelRequest =
      (object.addInputChannelRequest !== undefined && object.addInputChannelRequest !== null)
        ? AddInputChannelRequest.fromPartial(object.addInputChannelRequest)
        : undefined;
    message.addPartitioningRequest =
      (object.addPartitioningRequest !== undefined && object.addPartitioningRequest !== null)
        ? AddPartitioningRequest.fromPartial(object.addPartitioningRequest)
        : undefined;
    message.assignPortRequest = (object.assignPortRequest !== undefined && object.assignPortRequest !== null)
      ? AssignPortRequest.fromPartial(object.assignPortRequest)
      : undefined;
    message.finalizeCheckpointRequest =
      (object.finalizeCheckpointRequest !== undefined && object.finalizeCheckpointRequest !== null)
        ? FinalizeCheckpointRequest.fromPartial(object.finalizeCheckpointRequest)
        : undefined;
    message.initializeExecutorRequest =
      (object.initializeExecutorRequest !== undefined && object.initializeExecutorRequest !== null)
        ? InitializeExecutorRequest.fromPartial(object.initializeExecutorRequest)
        : undefined;
    message.updateExecutorRequest =
      (object.updateExecutorRequest !== undefined && object.updateExecutorRequest !== null)
        ? UpdateExecutorRequest.fromPartial(object.updateExecutorRequest)
        : undefined;
    message.emptyRequest = (object.emptyRequest !== undefined && object.emptyRequest !== null)
      ? EmptyRequest.fromPartial(object.emptyRequest)
      : undefined;
    message.prepareCheckpointRequest =
      (object.prepareCheckpointRequest !== undefined && object.prepareCheckpointRequest !== null)
        ? PrepareCheckpointRequest.fromPartial(object.prepareCheckpointRequest)
        : undefined;
    message.queryStatisticsRequest =
      (object.queryStatisticsRequest !== undefined && object.queryStatisticsRequest !== null)
        ? QueryStatisticsRequest.fromPartial(object.queryStatisticsRequest)
        : undefined;
    message.ping = (object.ping !== undefined && object.ping !== null) ? Ping.fromPartial(object.ping) : undefined;
    message.pong = (object.pong !== undefined && object.pong !== null) ? Pong.fromPartial(object.pong) : undefined;
    message.nested = (object.nested !== undefined && object.nested !== null)
      ? Nested.fromPartial(object.nested)
      : undefined;
    message.pass = (object.pass !== undefined && object.pass !== null) ? Pass.fromPartial(object.pass) : undefined;
    message.errorCommand = (object.errorCommand !== undefined && object.errorCommand !== null)
      ? ErrorCommand.fromPartial(object.errorCommand)
      : undefined;
    message.recursion = (object.recursion !== undefined && object.recursion !== null)
      ? Recursion.fromPartial(object.recursion)
      : undefined;
    message.collect = (object.collect !== undefined && object.collect !== null)
      ? Collect.fromPartial(object.collect)
      : undefined;
    message.generateNumber = (object.generateNumber !== undefined && object.generateNumber !== null)
      ? GenerateNumber.fromPartial(object.generateNumber)
      : undefined;
    message.multiCall = (object.multiCall !== undefined && object.multiCall !== null)
      ? MultiCall.fromPartial(object.multiCall)
      : undefined;
    message.chain = (object.chain !== undefined && object.chain !== null) ? Chain.fromPartial(object.chain) : undefined;
    return message;
  },
};

function createBaseEmptyRequest(): EmptyRequest {
  return {};
}

export const EmptyRequest: MessageFns<EmptyRequest> = {
  encode(_: EmptyRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EmptyRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEmptyRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): EmptyRequest {
    return {};
  },

  toJSON(_: EmptyRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<EmptyRequest>, I>>(base?: I): EmptyRequest {
    return EmptyRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EmptyRequest>, I>>(_: I): EmptyRequest {
    const message = createBaseEmptyRequest();
    return message;
  },
};

function createBaseAsyncRPCContext(): AsyncRPCContext {
  return { sender: undefined, receiver: undefined };
}

export const AsyncRPCContext: MessageFns<AsyncRPCContext> = {
  encode(message: AsyncRPCContext, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.sender !== undefined) {
      ActorVirtualIdentity.encode(message.sender, writer.uint32(10).fork()).join();
    }
    if (message.receiver !== undefined) {
      ActorVirtualIdentity.encode(message.receiver, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AsyncRPCContext {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAsyncRPCContext();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.sender = ActorVirtualIdentity.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.receiver = ActorVirtualIdentity.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AsyncRPCContext {
    return {
      sender: isSet(object.sender) ? ActorVirtualIdentity.fromJSON(object.sender) : undefined,
      receiver: isSet(object.receiver) ? ActorVirtualIdentity.fromJSON(object.receiver) : undefined,
    };
  },

  toJSON(message: AsyncRPCContext): unknown {
    const obj: any = {};
    if (message.sender !== undefined) {
      obj.sender = ActorVirtualIdentity.toJSON(message.sender);
    }
    if (message.receiver !== undefined) {
      obj.receiver = ActorVirtualIdentity.toJSON(message.receiver);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AsyncRPCContext>, I>>(base?: I): AsyncRPCContext {
    return AsyncRPCContext.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AsyncRPCContext>, I>>(object: I): AsyncRPCContext {
    const message = createBaseAsyncRPCContext();
    message.sender = (object.sender !== undefined && object.sender !== null)
      ? ActorVirtualIdentity.fromPartial(object.sender)
      : undefined;
    message.receiver = (object.receiver !== undefined && object.receiver !== null)
      ? ActorVirtualIdentity.fromPartial(object.receiver)
      : undefined;
    return message;
  },
};

function createBaseControlInvocation(): ControlInvocation {
  return { methodName: "", command: undefined, context: undefined, commandId: 0 };
}

export const ControlInvocation: MessageFns<ControlInvocation> = {
  encode(message: ControlInvocation, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.methodName !== "") {
      writer.uint32(10).string(message.methodName);
    }
    if (message.command !== undefined) {
      ControlRequest.encode(message.command, writer.uint32(18).fork()).join();
    }
    if (message.context !== undefined) {
      AsyncRPCContext.encode(message.context, writer.uint32(26).fork()).join();
    }
    if (message.commandId !== 0) {
      writer.uint32(32).int64(message.commandId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ControlInvocation {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseControlInvocation();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.methodName = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.command = ControlRequest.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.context = AsyncRPCContext.decode(reader, reader.uint32());
          continue;
        case 4:
          if (tag !== 32) {
            break;
          }

          message.commandId = longToNumber(reader.int64());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ControlInvocation {
    return {
      methodName: isSet(object.methodName) ? globalThis.String(object.methodName) : "",
      command: isSet(object.command) ? ControlRequest.fromJSON(object.command) : undefined,
      context: isSet(object.context) ? AsyncRPCContext.fromJSON(object.context) : undefined,
      commandId: isSet(object.commandId) ? globalThis.Number(object.commandId) : 0,
    };
  },

  toJSON(message: ControlInvocation): unknown {
    const obj: any = {};
    if (message.methodName !== "") {
      obj.methodName = message.methodName;
    }
    if (message.command !== undefined) {
      obj.command = ControlRequest.toJSON(message.command);
    }
    if (message.context !== undefined) {
      obj.context = AsyncRPCContext.toJSON(message.context);
    }
    if (message.commandId !== 0) {
      obj.commandId = Math.round(message.commandId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ControlInvocation>, I>>(base?: I): ControlInvocation {
    return ControlInvocation.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ControlInvocation>, I>>(object: I): ControlInvocation {
    const message = createBaseControlInvocation();
    message.methodName = object.methodName ?? "";
    message.command = (object.command !== undefined && object.command !== null)
      ? ControlRequest.fromPartial(object.command)
      : undefined;
    message.context = (object.context !== undefined && object.context !== null)
      ? AsyncRPCContext.fromPartial(object.context)
      : undefined;
    message.commandId = object.commandId ?? 0;
    return message;
  },
};

function createBaseChannelMarkerPayload(): ChannelMarkerPayload {
  return { id: undefined, markerType: 0, scope: [], commandMapping: {} };
}

export const ChannelMarkerPayload: MessageFns<ChannelMarkerPayload> = {
  encode(message: ChannelMarkerPayload, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== undefined) {
      ChannelMarkerIdentity.encode(message.id, writer.uint32(10).fork()).join();
    }
    if (message.markerType !== 0) {
      writer.uint32(16).int32(message.markerType);
    }
    for (const v of message.scope) {
      ChannelIdentity.encode(v!, writer.uint32(26).fork()).join();
    }
    Object.entries(message.commandMapping).forEach(([key, value]) => {
      ChannelMarkerPayload_CommandMappingEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ChannelMarkerPayload {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChannelMarkerPayload();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.id = ChannelMarkerIdentity.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.markerType = reader.int32() as any;
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.scope.push(ChannelIdentity.decode(reader, reader.uint32()));
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          const entry4 = ChannelMarkerPayload_CommandMappingEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.commandMapping[entry4.key] = entry4.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChannelMarkerPayload {
    return {
      id: isSet(object.id) ? ChannelMarkerIdentity.fromJSON(object.id) : undefined,
      markerType: isSet(object.markerType) ? channelMarkerTypeFromJSON(object.markerType) : 0,
      scope: globalThis.Array.isArray(object?.scope) ? object.scope.map((e: any) => ChannelIdentity.fromJSON(e)) : [],
      commandMapping: isObject(object.commandMapping)
        ? Object.entries(object.commandMapping).reduce<{ [key: string]: ControlInvocation }>((acc, [key, value]) => {
          acc[key] = ControlInvocation.fromJSON(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: ChannelMarkerPayload): unknown {
    const obj: any = {};
    if (message.id !== undefined) {
      obj.id = ChannelMarkerIdentity.toJSON(message.id);
    }
    if (message.markerType !== 0) {
      obj.markerType = channelMarkerTypeToJSON(message.markerType);
    }
    if (message.scope?.length) {
      obj.scope = message.scope.map((e) => ChannelIdentity.toJSON(e));
    }
    if (message.commandMapping) {
      const entries = Object.entries(message.commandMapping);
      if (entries.length > 0) {
        obj.commandMapping = {};
        entries.forEach(([k, v]) => {
          obj.commandMapping[k] = ControlInvocation.toJSON(v);
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ChannelMarkerPayload>, I>>(base?: I): ChannelMarkerPayload {
    return ChannelMarkerPayload.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ChannelMarkerPayload>, I>>(object: I): ChannelMarkerPayload {
    const message = createBaseChannelMarkerPayload();
    message.id = (object.id !== undefined && object.id !== null)
      ? ChannelMarkerIdentity.fromPartial(object.id)
      : undefined;
    message.markerType = object.markerType ?? 0;
    message.scope = object.scope?.map((e) => ChannelIdentity.fromPartial(e)) || [];
    message.commandMapping = Object.entries(object.commandMapping ?? {}).reduce<{ [key: string]: ControlInvocation }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = ControlInvocation.fromPartial(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseChannelMarkerPayload_CommandMappingEntry(): ChannelMarkerPayload_CommandMappingEntry {
  return { key: "", value: undefined };
}

export const ChannelMarkerPayload_CommandMappingEntry: MessageFns<ChannelMarkerPayload_CommandMappingEntry> = {
  encode(message: ChannelMarkerPayload_CommandMappingEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== undefined) {
      ControlInvocation.encode(message.value, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ChannelMarkerPayload_CommandMappingEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChannelMarkerPayload_CommandMappingEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = ControlInvocation.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ChannelMarkerPayload_CommandMappingEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? ControlInvocation.fromJSON(object.value) : undefined,
    };
  },

  toJSON(message: ChannelMarkerPayload_CommandMappingEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== undefined) {
      obj.value = ControlInvocation.toJSON(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ChannelMarkerPayload_CommandMappingEntry>, I>>(
    base?: I,
  ): ChannelMarkerPayload_CommandMappingEntry {
    return ChannelMarkerPayload_CommandMappingEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ChannelMarkerPayload_CommandMappingEntry>, I>>(
    object: I,
  ): ChannelMarkerPayload_CommandMappingEntry {
    const message = createBaseChannelMarkerPayload_CommandMappingEntry();
    message.key = object.key ?? "";
    message.value = (object.value !== undefined && object.value !== null)
      ? ControlInvocation.fromPartial(object.value)
      : undefined;
    return message;
  },
};

function createBasePropagateChannelMarkerRequest(): PropagateChannelMarkerRequest {
  return {
    sourceOpToStartProp: [],
    id: undefined,
    markerType: 0,
    scope: [],
    targetOps: [],
    markerCommand: undefined,
    markerMethodName: "",
  };
}

export const PropagateChannelMarkerRequest: MessageFns<PropagateChannelMarkerRequest> = {
  encode(message: PropagateChannelMarkerRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.sourceOpToStartProp) {
      PhysicalOpIdentity.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.id !== undefined) {
      ChannelMarkerIdentity.encode(message.id, writer.uint32(18).fork()).join();
    }
    if (message.markerType !== 0) {
      writer.uint32(24).int32(message.markerType);
    }
    for (const v of message.scope) {
      PhysicalOpIdentity.encode(v!, writer.uint32(34).fork()).join();
    }
    for (const v of message.targetOps) {
      PhysicalOpIdentity.encode(v!, writer.uint32(42).fork()).join();
    }
    if (message.markerCommand !== undefined) {
      ControlRequest.encode(message.markerCommand, writer.uint32(50).fork()).join();
    }
    if (message.markerMethodName !== "") {
      writer.uint32(58).string(message.markerMethodName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PropagateChannelMarkerRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePropagateChannelMarkerRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.sourceOpToStartProp.push(PhysicalOpIdentity.decode(reader, reader.uint32()));
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.id = ChannelMarkerIdentity.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.markerType = reader.int32() as any;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.scope.push(PhysicalOpIdentity.decode(reader, reader.uint32()));
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.targetOps.push(PhysicalOpIdentity.decode(reader, reader.uint32()));
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.markerCommand = ControlRequest.decode(reader, reader.uint32());
          continue;
        case 7:
          if (tag !== 58) {
            break;
          }

          message.markerMethodName = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PropagateChannelMarkerRequest {
    return {
      sourceOpToStartProp: globalThis.Array.isArray(object?.sourceOpToStartProp)
        ? object.sourceOpToStartProp.map((e: any) => PhysicalOpIdentity.fromJSON(e))
        : [],
      id: isSet(object.id) ? ChannelMarkerIdentity.fromJSON(object.id) : undefined,
      markerType: isSet(object.markerType) ? channelMarkerTypeFromJSON(object.markerType) : 0,
      scope: globalThis.Array.isArray(object?.scope)
        ? object.scope.map((e: any) => PhysicalOpIdentity.fromJSON(e))
        : [],
      targetOps: globalThis.Array.isArray(object?.targetOps)
        ? object.targetOps.map((e: any) => PhysicalOpIdentity.fromJSON(e))
        : [],
      markerCommand: isSet(object.markerCommand) ? ControlRequest.fromJSON(object.markerCommand) : undefined,
      markerMethodName: isSet(object.markerMethodName) ? globalThis.String(object.markerMethodName) : "",
    };
  },

  toJSON(message: PropagateChannelMarkerRequest): unknown {
    const obj: any = {};
    if (message.sourceOpToStartProp?.length) {
      obj.sourceOpToStartProp = message.sourceOpToStartProp.map((e) => PhysicalOpIdentity.toJSON(e));
    }
    if (message.id !== undefined) {
      obj.id = ChannelMarkerIdentity.toJSON(message.id);
    }
    if (message.markerType !== 0) {
      obj.markerType = channelMarkerTypeToJSON(message.markerType);
    }
    if (message.scope?.length) {
      obj.scope = message.scope.map((e) => PhysicalOpIdentity.toJSON(e));
    }
    if (message.targetOps?.length) {
      obj.targetOps = message.targetOps.map((e) => PhysicalOpIdentity.toJSON(e));
    }
    if (message.markerCommand !== undefined) {
      obj.markerCommand = ControlRequest.toJSON(message.markerCommand);
    }
    if (message.markerMethodName !== "") {
      obj.markerMethodName = message.markerMethodName;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PropagateChannelMarkerRequest>, I>>(base?: I): PropagateChannelMarkerRequest {
    return PropagateChannelMarkerRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PropagateChannelMarkerRequest>, I>>(
    object: I,
  ): PropagateChannelMarkerRequest {
    const message = createBasePropagateChannelMarkerRequest();
    message.sourceOpToStartProp = object.sourceOpToStartProp?.map((e) => PhysicalOpIdentity.fromPartial(e)) || [];
    message.id = (object.id !== undefined && object.id !== null)
      ? ChannelMarkerIdentity.fromPartial(object.id)
      : undefined;
    message.markerType = object.markerType ?? 0;
    message.scope = object.scope?.map((e) => PhysicalOpIdentity.fromPartial(e)) || [];
    message.targetOps = object.targetOps?.map((e) => PhysicalOpIdentity.fromPartial(e)) || [];
    message.markerCommand = (object.markerCommand !== undefined && object.markerCommand !== null)
      ? ControlRequest.fromPartial(object.markerCommand)
      : undefined;
    message.markerMethodName = object.markerMethodName ?? "";
    return message;
  },
};

function createBaseTakeGlobalCheckpointRequest(): TakeGlobalCheckpointRequest {
  return { estimationOnly: false, checkpointId: undefined, destination: "" };
}

export const TakeGlobalCheckpointRequest: MessageFns<TakeGlobalCheckpointRequest> = {
  encode(message: TakeGlobalCheckpointRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.estimationOnly !== false) {
      writer.uint32(8).bool(message.estimationOnly);
    }
    if (message.checkpointId !== undefined) {
      ChannelMarkerIdentity.encode(message.checkpointId, writer.uint32(18).fork()).join();
    }
    if (message.destination !== "") {
      writer.uint32(26).string(message.destination);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TakeGlobalCheckpointRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTakeGlobalCheckpointRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.estimationOnly = reader.bool();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.checkpointId = ChannelMarkerIdentity.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.destination = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TakeGlobalCheckpointRequest {
    return {
      estimationOnly: isSet(object.estimationOnly) ? globalThis.Boolean(object.estimationOnly) : false,
      checkpointId: isSet(object.checkpointId) ? ChannelMarkerIdentity.fromJSON(object.checkpointId) : undefined,
      destination: isSet(object.destination) ? globalThis.String(object.destination) : "",
    };
  },

  toJSON(message: TakeGlobalCheckpointRequest): unknown {
    const obj: any = {};
    if (message.estimationOnly !== false) {
      obj.estimationOnly = message.estimationOnly;
    }
    if (message.checkpointId !== undefined) {
      obj.checkpointId = ChannelMarkerIdentity.toJSON(message.checkpointId);
    }
    if (message.destination !== "") {
      obj.destination = message.destination;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TakeGlobalCheckpointRequest>, I>>(base?: I): TakeGlobalCheckpointRequest {
    return TakeGlobalCheckpointRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TakeGlobalCheckpointRequest>, I>>(object: I): TakeGlobalCheckpointRequest {
    const message = createBaseTakeGlobalCheckpointRequest();
    message.estimationOnly = object.estimationOnly ?? false;
    message.checkpointId = (object.checkpointId !== undefined && object.checkpointId !== null)
      ? ChannelMarkerIdentity.fromPartial(object.checkpointId)
      : undefined;
    message.destination = object.destination ?? "";
    return message;
  },
};

function createBaseWorkflowReconfigureRequest(): WorkflowReconfigureRequest {
  return { reconfiguration: undefined, reconfigurationId: "" };
}

export const WorkflowReconfigureRequest: MessageFns<WorkflowReconfigureRequest> = {
  encode(message: WorkflowReconfigureRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.reconfiguration !== undefined) {
      ModifyLogicRequest.encode(message.reconfiguration, writer.uint32(10).fork()).join();
    }
    if (message.reconfigurationId !== "") {
      writer.uint32(18).string(message.reconfigurationId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WorkflowReconfigureRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWorkflowReconfigureRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.reconfiguration = ModifyLogicRequest.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.reconfigurationId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WorkflowReconfigureRequest {
    return {
      reconfiguration: isSet(object.reconfiguration) ? ModifyLogicRequest.fromJSON(object.reconfiguration) : undefined,
      reconfigurationId: isSet(object.reconfigurationId) ? globalThis.String(object.reconfigurationId) : "",
    };
  },

  toJSON(message: WorkflowReconfigureRequest): unknown {
    const obj: any = {};
    if (message.reconfiguration !== undefined) {
      obj.reconfiguration = ModifyLogicRequest.toJSON(message.reconfiguration);
    }
    if (message.reconfigurationId !== "") {
      obj.reconfigurationId = message.reconfigurationId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WorkflowReconfigureRequest>, I>>(base?: I): WorkflowReconfigureRequest {
    return WorkflowReconfigureRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WorkflowReconfigureRequest>, I>>(object: I): WorkflowReconfigureRequest {
    const message = createBaseWorkflowReconfigureRequest();
    message.reconfiguration = (object.reconfiguration !== undefined && object.reconfiguration !== null)
      ? ModifyLogicRequest.fromPartial(object.reconfiguration)
      : undefined;
    message.reconfigurationId = object.reconfigurationId ?? "";
    return message;
  },
};

function createBaseDebugCommandRequest(): DebugCommandRequest {
  return { workerId: "", cmd: "" };
}

export const DebugCommandRequest: MessageFns<DebugCommandRequest> = {
  encode(message: DebugCommandRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.workerId !== "") {
      writer.uint32(10).string(message.workerId);
    }
    if (message.cmd !== "") {
      writer.uint32(18).string(message.cmd);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DebugCommandRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDebugCommandRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.workerId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.cmd = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DebugCommandRequest {
    return {
      workerId: isSet(object.workerId) ? globalThis.String(object.workerId) : "",
      cmd: isSet(object.cmd) ? globalThis.String(object.cmd) : "",
    };
  },

  toJSON(message: DebugCommandRequest): unknown {
    const obj: any = {};
    if (message.workerId !== "") {
      obj.workerId = message.workerId;
    }
    if (message.cmd !== "") {
      obj.cmd = message.cmd;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DebugCommandRequest>, I>>(base?: I): DebugCommandRequest {
    return DebugCommandRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DebugCommandRequest>, I>>(object: I): DebugCommandRequest {
    const message = createBaseDebugCommandRequest();
    message.workerId = object.workerId ?? "";
    message.cmd = object.cmd ?? "";
    return message;
  },
};

function createBaseEvaluatePythonExpressionRequest(): EvaluatePythonExpressionRequest {
  return { expression: "", operatorId: "" };
}

export const EvaluatePythonExpressionRequest: MessageFns<EvaluatePythonExpressionRequest> = {
  encode(message: EvaluatePythonExpressionRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.expression !== "") {
      writer.uint32(10).string(message.expression);
    }
    if (message.operatorId !== "") {
      writer.uint32(18).string(message.operatorId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): EvaluatePythonExpressionRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEvaluatePythonExpressionRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.expression = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.operatorId = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): EvaluatePythonExpressionRequest {
    return {
      expression: isSet(object.expression) ? globalThis.String(object.expression) : "",
      operatorId: isSet(object.operatorId) ? globalThis.String(object.operatorId) : "",
    };
  },

  toJSON(message: EvaluatePythonExpressionRequest): unknown {
    const obj: any = {};
    if (message.expression !== "") {
      obj.expression = message.expression;
    }
    if (message.operatorId !== "") {
      obj.operatorId = message.operatorId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<EvaluatePythonExpressionRequest>, I>>(base?: I): EvaluatePythonExpressionRequest {
    return EvaluatePythonExpressionRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<EvaluatePythonExpressionRequest>, I>>(
    object: I,
  ): EvaluatePythonExpressionRequest {
    const message = createBaseEvaluatePythonExpressionRequest();
    message.expression = object.expression ?? "";
    message.operatorId = object.operatorId ?? "";
    return message;
  },
};

function createBaseModifyLogicRequest(): ModifyLogicRequest {
  return { updateRequest: [] };
}

export const ModifyLogicRequest: MessageFns<ModifyLogicRequest> = {
  encode(message: ModifyLogicRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.updateRequest) {
      UpdateExecutorRequest.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ModifyLogicRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseModifyLogicRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.updateRequest.push(UpdateExecutorRequest.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ModifyLogicRequest {
    return {
      updateRequest: globalThis.Array.isArray(object?.updateRequest)
        ? object.updateRequest.map((e: any) => UpdateExecutorRequest.fromJSON(e))
        : [],
    };
  },

  toJSON(message: ModifyLogicRequest): unknown {
    const obj: any = {};
    if (message.updateRequest?.length) {
      obj.updateRequest = message.updateRequest.map((e) => UpdateExecutorRequest.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ModifyLogicRequest>, I>>(base?: I): ModifyLogicRequest {
    return ModifyLogicRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ModifyLogicRequest>, I>>(object: I): ModifyLogicRequest {
    const message = createBaseModifyLogicRequest();
    message.updateRequest = object.updateRequest?.map((e) => UpdateExecutorRequest.fromPartial(e)) || [];
    return message;
  },
};

function createBaseRetryWorkflowRequest(): RetryWorkflowRequest {
  return { workers: [] };
}

export const RetryWorkflowRequest: MessageFns<RetryWorkflowRequest> = {
  encode(message: RetryWorkflowRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.workers) {
      ActorVirtualIdentity.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RetryWorkflowRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRetryWorkflowRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.workers.push(ActorVirtualIdentity.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RetryWorkflowRequest {
    return {
      workers: globalThis.Array.isArray(object?.workers)
        ? object.workers.map((e: any) => ActorVirtualIdentity.fromJSON(e))
        : [],
    };
  },

  toJSON(message: RetryWorkflowRequest): unknown {
    const obj: any = {};
    if (message.workers?.length) {
      obj.workers = message.workers.map((e) => ActorVirtualIdentity.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RetryWorkflowRequest>, I>>(base?: I): RetryWorkflowRequest {
    return RetryWorkflowRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RetryWorkflowRequest>, I>>(object: I): RetryWorkflowRequest {
    const message = createBaseRetryWorkflowRequest();
    message.workers = object.workers?.map((e) => ActorVirtualIdentity.fromPartial(e)) || [];
    return message;
  },
};

function createBaseConsoleMessage(): ConsoleMessage {
  return { workerId: "", timestamp: undefined, msgType: 0, source: "", title: "", message: "" };
}

export const ConsoleMessage: MessageFns<ConsoleMessage> = {
  encode(message: ConsoleMessage, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.workerId !== "") {
      writer.uint32(10).string(message.workerId);
    }
    if (message.timestamp !== undefined) {
      Timestamp.encode(toTimestamp(message.timestamp), writer.uint32(18).fork()).join();
    }
    if (message.msgType !== 0) {
      writer.uint32(24).int32(message.msgType);
    }
    if (message.source !== "") {
      writer.uint32(34).string(message.source);
    }
    if (message.title !== "") {
      writer.uint32(42).string(message.title);
    }
    if (message.message !== "") {
      writer.uint32(50).string(message.message);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ConsoleMessage {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConsoleMessage();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.workerId = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.timestamp = fromTimestamp(Timestamp.decode(reader, reader.uint32()));
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.msgType = reader.int32() as any;
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.source = reader.string();
          continue;
        case 5:
          if (tag !== 42) {
            break;
          }

          message.title = reader.string();
          continue;
        case 6:
          if (tag !== 50) {
            break;
          }

          message.message = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConsoleMessage {
    return {
      workerId: isSet(object.workerId) ? globalThis.String(object.workerId) : "",
      timestamp: isSet(object.timestamp) ? fromJsonTimestamp(object.timestamp) : undefined,
      msgType: isSet(object.msgType) ? consoleMessageTypeFromJSON(object.msgType) : 0,
      source: isSet(object.source) ? globalThis.String(object.source) : "",
      title: isSet(object.title) ? globalThis.String(object.title) : "",
      message: isSet(object.message) ? globalThis.String(object.message) : "",
    };
  },

  toJSON(message: ConsoleMessage): unknown {
    const obj: any = {};
    if (message.workerId !== "") {
      obj.workerId = message.workerId;
    }
    if (message.timestamp !== undefined) {
      obj.timestamp = message.timestamp.toISOString();
    }
    if (message.msgType !== 0) {
      obj.msgType = consoleMessageTypeToJSON(message.msgType);
    }
    if (message.source !== "") {
      obj.source = message.source;
    }
    if (message.title !== "") {
      obj.title = message.title;
    }
    if (message.message !== "") {
      obj.message = message.message;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ConsoleMessage>, I>>(base?: I): ConsoleMessage {
    return ConsoleMessage.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ConsoleMessage>, I>>(object: I): ConsoleMessage {
    const message = createBaseConsoleMessage();
    message.workerId = object.workerId ?? "";
    message.timestamp = object.timestamp ?? undefined;
    message.msgType = object.msgType ?? 0;
    message.source = object.source ?? "";
    message.title = object.title ?? "";
    message.message = object.message ?? "";
    return message;
  },
};

function createBaseConsoleMessageTriggeredRequest(): ConsoleMessageTriggeredRequest {
  return { consoleMessage: undefined };
}

export const ConsoleMessageTriggeredRequest: MessageFns<ConsoleMessageTriggeredRequest> = {
  encode(message: ConsoleMessageTriggeredRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.consoleMessage !== undefined) {
      ConsoleMessage.encode(message.consoleMessage, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ConsoleMessageTriggeredRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseConsoleMessageTriggeredRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.consoleMessage = ConsoleMessage.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ConsoleMessageTriggeredRequest {
    return {
      consoleMessage: isSet(object.consoleMessage) ? ConsoleMessage.fromJSON(object.consoleMessage) : undefined,
    };
  },

  toJSON(message: ConsoleMessageTriggeredRequest): unknown {
    const obj: any = {};
    if (message.consoleMessage !== undefined) {
      obj.consoleMessage = ConsoleMessage.toJSON(message.consoleMessage);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ConsoleMessageTriggeredRequest>, I>>(base?: I): ConsoleMessageTriggeredRequest {
    return ConsoleMessageTriggeredRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ConsoleMessageTriggeredRequest>, I>>(
    object: I,
  ): ConsoleMessageTriggeredRequest {
    const message = createBaseConsoleMessageTriggeredRequest();
    message.consoleMessage = (object.consoleMessage !== undefined && object.consoleMessage !== null)
      ? ConsoleMessage.fromPartial(object.consoleMessage)
      : undefined;
    return message;
  },
};

function createBasePortCompletedRequest(): PortCompletedRequest {
  return { portId: undefined, input: false };
}

export const PortCompletedRequest: MessageFns<PortCompletedRequest> = {
  encode(message: PortCompletedRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.portId !== undefined) {
      PortIdentity.encode(message.portId, writer.uint32(10).fork()).join();
    }
    if (message.input !== false) {
      writer.uint32(16).bool(message.input);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PortCompletedRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePortCompletedRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.portId = PortIdentity.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.input = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PortCompletedRequest {
    return {
      portId: isSet(object.portId) ? PortIdentity.fromJSON(object.portId) : undefined,
      input: isSet(object.input) ? globalThis.Boolean(object.input) : false,
    };
  },

  toJSON(message: PortCompletedRequest): unknown {
    const obj: any = {};
    if (message.portId !== undefined) {
      obj.portId = PortIdentity.toJSON(message.portId);
    }
    if (message.input !== false) {
      obj.input = message.input;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PortCompletedRequest>, I>>(base?: I): PortCompletedRequest {
    return PortCompletedRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PortCompletedRequest>, I>>(object: I): PortCompletedRequest {
    const message = createBasePortCompletedRequest();
    message.portId = (object.portId !== undefined && object.portId !== null)
      ? PortIdentity.fromPartial(object.portId)
      : undefined;
    message.input = object.input ?? false;
    return message;
  },
};

function createBaseWorkerStateUpdatedRequest(): WorkerStateUpdatedRequest {
  return { state: 0 };
}

export const WorkerStateUpdatedRequest: MessageFns<WorkerStateUpdatedRequest> = {
  encode(message: WorkerStateUpdatedRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.state !== 0) {
      writer.uint32(8).int32(message.state);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WorkerStateUpdatedRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWorkerStateUpdatedRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.state = reader.int32() as any;
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WorkerStateUpdatedRequest {
    return { state: isSet(object.state) ? workerStateFromJSON(object.state) : 0 };
  },

  toJSON(message: WorkerStateUpdatedRequest): unknown {
    const obj: any = {};
    if (message.state !== 0) {
      obj.state = workerStateToJSON(message.state);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WorkerStateUpdatedRequest>, I>>(base?: I): WorkerStateUpdatedRequest {
    return WorkerStateUpdatedRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WorkerStateUpdatedRequest>, I>>(object: I): WorkerStateUpdatedRequest {
    const message = createBaseWorkerStateUpdatedRequest();
    message.state = object.state ?? 0;
    return message;
  },
};

function createBaseLinkWorkersRequest(): LinkWorkersRequest {
  return { link: undefined };
}

export const LinkWorkersRequest: MessageFns<LinkWorkersRequest> = {
  encode(message: LinkWorkersRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.link !== undefined) {
      PhysicalLink.encode(message.link, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LinkWorkersRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLinkWorkersRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.link = PhysicalLink.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LinkWorkersRequest {
    return { link: isSet(object.link) ? PhysicalLink.fromJSON(object.link) : undefined };
  },

  toJSON(message: LinkWorkersRequest): unknown {
    const obj: any = {};
    if (message.link !== undefined) {
      obj.link = PhysicalLink.toJSON(message.link);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LinkWorkersRequest>, I>>(base?: I): LinkWorkersRequest {
    return LinkWorkersRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LinkWorkersRequest>, I>>(object: I): LinkWorkersRequest {
    const message = createBaseLinkWorkersRequest();
    message.link = (object.link !== undefined && object.link !== null)
      ? PhysicalLink.fromPartial(object.link)
      : undefined;
    return message;
  },
};

function createBasePing(): Ping {
  return { i: 0, end: 0, to: undefined };
}

export const Ping: MessageFns<Ping> = {
  encode(message: Ping, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.i !== 0) {
      writer.uint32(8).int32(message.i);
    }
    if (message.end !== 0) {
      writer.uint32(16).int32(message.end);
    }
    if (message.to !== undefined) {
      ActorVirtualIdentity.encode(message.to, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Ping {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePing();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.i = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.end = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.to = ActorVirtualIdentity.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Ping {
    return {
      i: isSet(object.i) ? globalThis.Number(object.i) : 0,
      end: isSet(object.end) ? globalThis.Number(object.end) : 0,
      to: isSet(object.to) ? ActorVirtualIdentity.fromJSON(object.to) : undefined,
    };
  },

  toJSON(message: Ping): unknown {
    const obj: any = {};
    if (message.i !== 0) {
      obj.i = Math.round(message.i);
    }
    if (message.end !== 0) {
      obj.end = Math.round(message.end);
    }
    if (message.to !== undefined) {
      obj.to = ActorVirtualIdentity.toJSON(message.to);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Ping>, I>>(base?: I): Ping {
    return Ping.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Ping>, I>>(object: I): Ping {
    const message = createBasePing();
    message.i = object.i ?? 0;
    message.end = object.end ?? 0;
    message.to = (object.to !== undefined && object.to !== null)
      ? ActorVirtualIdentity.fromPartial(object.to)
      : undefined;
    return message;
  },
};

function createBasePong(): Pong {
  return { i: 0, end: 0, to: undefined };
}

export const Pong: MessageFns<Pong> = {
  encode(message: Pong, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.i !== 0) {
      writer.uint32(8).int32(message.i);
    }
    if (message.end !== 0) {
      writer.uint32(16).int32(message.end);
    }
    if (message.to !== undefined) {
      ActorVirtualIdentity.encode(message.to, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Pong {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePong();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.i = reader.int32();
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.end = reader.int32();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.to = ActorVirtualIdentity.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Pong {
    return {
      i: isSet(object.i) ? globalThis.Number(object.i) : 0,
      end: isSet(object.end) ? globalThis.Number(object.end) : 0,
      to: isSet(object.to) ? ActorVirtualIdentity.fromJSON(object.to) : undefined,
    };
  },

  toJSON(message: Pong): unknown {
    const obj: any = {};
    if (message.i !== 0) {
      obj.i = Math.round(message.i);
    }
    if (message.end !== 0) {
      obj.end = Math.round(message.end);
    }
    if (message.to !== undefined) {
      obj.to = ActorVirtualIdentity.toJSON(message.to);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Pong>, I>>(base?: I): Pong {
    return Pong.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Pong>, I>>(object: I): Pong {
    const message = createBasePong();
    message.i = object.i ?? 0;
    message.end = object.end ?? 0;
    message.to = (object.to !== undefined && object.to !== null)
      ? ActorVirtualIdentity.fromPartial(object.to)
      : undefined;
    return message;
  },
};

function createBasePass(): Pass {
  return { value: "" };
}

export const Pass: MessageFns<Pass> = {
  encode(message: Pass, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.value !== "") {
      writer.uint32(10).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Pass {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePass();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Pass {
    return { value: isSet(object.value) ? globalThis.String(object.value) : "" };
  },

  toJSON(message: Pass): unknown {
    const obj: any = {};
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Pass>, I>>(base?: I): Pass {
    return Pass.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Pass>, I>>(object: I): Pass {
    const message = createBasePass();
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseNested(): Nested {
  return { k: 0 };
}

export const Nested: MessageFns<Nested> = {
  encode(message: Nested, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.k !== 0) {
      writer.uint32(8).int32(message.k);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Nested {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseNested();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.k = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Nested {
    return { k: isSet(object.k) ? globalThis.Number(object.k) : 0 };
  },

  toJSON(message: Nested): unknown {
    const obj: any = {};
    if (message.k !== 0) {
      obj.k = Math.round(message.k);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Nested>, I>>(base?: I): Nested {
    return Nested.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Nested>, I>>(object: I): Nested {
    const message = createBaseNested();
    message.k = object.k ?? 0;
    return message;
  },
};

function createBaseMultiCall(): MultiCall {
  return { seq: [] };
}

export const MultiCall: MessageFns<MultiCall> = {
  encode(message: MultiCall, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.seq) {
      ActorVirtualIdentity.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MultiCall {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMultiCall();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.seq.push(ActorVirtualIdentity.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MultiCall {
    return {
      seq: globalThis.Array.isArray(object?.seq) ? object.seq.map((e: any) => ActorVirtualIdentity.fromJSON(e)) : [],
    };
  },

  toJSON(message: MultiCall): unknown {
    const obj: any = {};
    if (message.seq?.length) {
      obj.seq = message.seq.map((e) => ActorVirtualIdentity.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MultiCall>, I>>(base?: I): MultiCall {
    return MultiCall.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MultiCall>, I>>(object: I): MultiCall {
    const message = createBaseMultiCall();
    message.seq = object.seq?.map((e) => ActorVirtualIdentity.fromPartial(e)) || [];
    return message;
  },
};

function createBaseErrorCommand(): ErrorCommand {
  return {};
}

export const ErrorCommand: MessageFns<ErrorCommand> = {
  encode(_: ErrorCommand, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ErrorCommand {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseErrorCommand();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): ErrorCommand {
    return {};
  },

  toJSON(_: ErrorCommand): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<ErrorCommand>, I>>(base?: I): ErrorCommand {
    return ErrorCommand.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ErrorCommand>, I>>(_: I): ErrorCommand {
    const message = createBaseErrorCommand();
    return message;
  },
};

function createBaseCollect(): Collect {
  return { workers: [] };
}

export const Collect: MessageFns<Collect> = {
  encode(message: Collect, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.workers) {
      ActorVirtualIdentity.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Collect {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCollect();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.workers.push(ActorVirtualIdentity.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Collect {
    return {
      workers: globalThis.Array.isArray(object?.workers)
        ? object.workers.map((e: any) => ActorVirtualIdentity.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Collect): unknown {
    const obj: any = {};
    if (message.workers?.length) {
      obj.workers = message.workers.map((e) => ActorVirtualIdentity.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Collect>, I>>(base?: I): Collect {
    return Collect.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Collect>, I>>(object: I): Collect {
    const message = createBaseCollect();
    message.workers = object.workers?.map((e) => ActorVirtualIdentity.fromPartial(e)) || [];
    return message;
  },
};

function createBaseGenerateNumber(): GenerateNumber {
  return {};
}

export const GenerateNumber: MessageFns<GenerateNumber> = {
  encode(_: GenerateNumber, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GenerateNumber {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGenerateNumber();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): GenerateNumber {
    return {};
  },

  toJSON(_: GenerateNumber): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<GenerateNumber>, I>>(base?: I): GenerateNumber {
    return GenerateNumber.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GenerateNumber>, I>>(_: I): GenerateNumber {
    const message = createBaseGenerateNumber();
    return message;
  },
};

function createBaseChain(): Chain {
  return { nexts: [] };
}

export const Chain: MessageFns<Chain> = {
  encode(message: Chain, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.nexts) {
      ActorVirtualIdentity.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Chain {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseChain();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.nexts.push(ActorVirtualIdentity.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Chain {
    return {
      nexts: globalThis.Array.isArray(object?.nexts)
        ? object.nexts.map((e: any) => ActorVirtualIdentity.fromJSON(e))
        : [],
    };
  },

  toJSON(message: Chain): unknown {
    const obj: any = {};
    if (message.nexts?.length) {
      obj.nexts = message.nexts.map((e) => ActorVirtualIdentity.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Chain>, I>>(base?: I): Chain {
    return Chain.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Chain>, I>>(object: I): Chain {
    const message = createBaseChain();
    message.nexts = object.nexts?.map((e) => ActorVirtualIdentity.fromPartial(e)) || [];
    return message;
  },
};

function createBaseRecursion(): Recursion {
  return { i: 0 };
}

export const Recursion: MessageFns<Recursion> = {
  encode(message: Recursion, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.i !== 0) {
      writer.uint32(8).int32(message.i);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Recursion {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRecursion();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.i = reader.int32();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Recursion {
    return { i: isSet(object.i) ? globalThis.Number(object.i) : 0 };
  },

  toJSON(message: Recursion): unknown {
    const obj: any = {};
    if (message.i !== 0) {
      obj.i = Math.round(message.i);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Recursion>, I>>(base?: I): Recursion {
    return Recursion.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Recursion>, I>>(object: I): Recursion {
    const message = createBaseRecursion();
    message.i = object.i ?? 0;
    return message;
  },
};

function createBaseAddInputChannelRequest(): AddInputChannelRequest {
  return { channelId: undefined, portId: undefined };
}

export const AddInputChannelRequest: MessageFns<AddInputChannelRequest> = {
  encode(message: AddInputChannelRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.channelId !== undefined) {
      ChannelIdentity.encode(message.channelId, writer.uint32(10).fork()).join();
    }
    if (message.portId !== undefined) {
      PortIdentity.encode(message.portId, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AddInputChannelRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddInputChannelRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.channelId = ChannelIdentity.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.portId = PortIdentity.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AddInputChannelRequest {
    return {
      channelId: isSet(object.channelId) ? ChannelIdentity.fromJSON(object.channelId) : undefined,
      portId: isSet(object.portId) ? PortIdentity.fromJSON(object.portId) : undefined,
    };
  },

  toJSON(message: AddInputChannelRequest): unknown {
    const obj: any = {};
    if (message.channelId !== undefined) {
      obj.channelId = ChannelIdentity.toJSON(message.channelId);
    }
    if (message.portId !== undefined) {
      obj.portId = PortIdentity.toJSON(message.portId);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AddInputChannelRequest>, I>>(base?: I): AddInputChannelRequest {
    return AddInputChannelRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AddInputChannelRequest>, I>>(object: I): AddInputChannelRequest {
    const message = createBaseAddInputChannelRequest();
    message.channelId = (object.channelId !== undefined && object.channelId !== null)
      ? ChannelIdentity.fromPartial(object.channelId)
      : undefined;
    message.portId = (object.portId !== undefined && object.portId !== null)
      ? PortIdentity.fromPartial(object.portId)
      : undefined;
    return message;
  },
};

function createBaseAddPartitioningRequest(): AddPartitioningRequest {
  return { tag: undefined, partitioning: undefined };
}

export const AddPartitioningRequest: MessageFns<AddPartitioningRequest> = {
  encode(message: AddPartitioningRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.tag !== undefined) {
      PhysicalLink.encode(message.tag, writer.uint32(10).fork()).join();
    }
    if (message.partitioning !== undefined) {
      Partitioning.encode(message.partitioning, writer.uint32(18).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AddPartitioningRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAddPartitioningRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.tag = PhysicalLink.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.partitioning = Partitioning.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AddPartitioningRequest {
    return {
      tag: isSet(object.tag) ? PhysicalLink.fromJSON(object.tag) : undefined,
      partitioning: isSet(object.partitioning) ? Partitioning.fromJSON(object.partitioning) : undefined,
    };
  },

  toJSON(message: AddPartitioningRequest): unknown {
    const obj: any = {};
    if (message.tag !== undefined) {
      obj.tag = PhysicalLink.toJSON(message.tag);
    }
    if (message.partitioning !== undefined) {
      obj.partitioning = Partitioning.toJSON(message.partitioning);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AddPartitioningRequest>, I>>(base?: I): AddPartitioningRequest {
    return AddPartitioningRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AddPartitioningRequest>, I>>(object: I): AddPartitioningRequest {
    const message = createBaseAddPartitioningRequest();
    message.tag = (object.tag !== undefined && object.tag !== null) ? PhysicalLink.fromPartial(object.tag) : undefined;
    message.partitioning = (object.partitioning !== undefined && object.partitioning !== null)
      ? Partitioning.fromPartial(object.partitioning)
      : undefined;
    return message;
  },
};

function createBaseAssignPortRequest(): AssignPortRequest {
  return { portId: undefined, input: false, schema: {} };
}

export const AssignPortRequest: MessageFns<AssignPortRequest> = {
  encode(message: AssignPortRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.portId !== undefined) {
      PortIdentity.encode(message.portId, writer.uint32(10).fork()).join();
    }
    if (message.input !== false) {
      writer.uint32(16).bool(message.input);
    }
    Object.entries(message.schema).forEach(([key, value]) => {
      AssignPortRequest_SchemaEntry.encode({ key: key as any, value }, writer.uint32(26).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AssignPortRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAssignPortRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.portId = PortIdentity.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.input = reader.bool();
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          const entry3 = AssignPortRequest_SchemaEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.schema[entry3.key] = entry3.value;
          }
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AssignPortRequest {
    return {
      portId: isSet(object.portId) ? PortIdentity.fromJSON(object.portId) : undefined,
      input: isSet(object.input) ? globalThis.Boolean(object.input) : false,
      schema: isObject(object.schema)
        ? Object.entries(object.schema).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: AssignPortRequest): unknown {
    const obj: any = {};
    if (message.portId !== undefined) {
      obj.portId = PortIdentity.toJSON(message.portId);
    }
    if (message.input !== false) {
      obj.input = message.input;
    }
    if (message.schema) {
      const entries = Object.entries(message.schema);
      if (entries.length > 0) {
        obj.schema = {};
        entries.forEach(([k, v]) => {
          obj.schema[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AssignPortRequest>, I>>(base?: I): AssignPortRequest {
    return AssignPortRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AssignPortRequest>, I>>(object: I): AssignPortRequest {
    const message = createBaseAssignPortRequest();
    message.portId = (object.portId !== undefined && object.portId !== null)
      ? PortIdentity.fromPartial(object.portId)
      : undefined;
    message.input = object.input ?? false;
    message.schema = Object.entries(object.schema ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseAssignPortRequest_SchemaEntry(): AssignPortRequest_SchemaEntry {
  return { key: "", value: "" };
}

export const AssignPortRequest_SchemaEntry: MessageFns<AssignPortRequest_SchemaEntry> = {
  encode(message: AssignPortRequest_SchemaEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): AssignPortRequest_SchemaEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseAssignPortRequest_SchemaEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): AssignPortRequest_SchemaEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: AssignPortRequest_SchemaEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<AssignPortRequest_SchemaEntry>, I>>(base?: I): AssignPortRequest_SchemaEntry {
    return AssignPortRequest_SchemaEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<AssignPortRequest_SchemaEntry>, I>>(
    object: I,
  ): AssignPortRequest_SchemaEntry {
    const message = createBaseAssignPortRequest_SchemaEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseFinalizeCheckpointRequest(): FinalizeCheckpointRequest {
  return { checkpointId: undefined, writeTo: "" };
}

export const FinalizeCheckpointRequest: MessageFns<FinalizeCheckpointRequest> = {
  encode(message: FinalizeCheckpointRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.checkpointId !== undefined) {
      ChannelMarkerIdentity.encode(message.checkpointId, writer.uint32(10).fork()).join();
    }
    if (message.writeTo !== "") {
      writer.uint32(18).string(message.writeTo);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FinalizeCheckpointRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFinalizeCheckpointRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.checkpointId = ChannelMarkerIdentity.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.writeTo = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FinalizeCheckpointRequest {
    return {
      checkpointId: isSet(object.checkpointId) ? ChannelMarkerIdentity.fromJSON(object.checkpointId) : undefined,
      writeTo: isSet(object.writeTo) ? globalThis.String(object.writeTo) : "",
    };
  },

  toJSON(message: FinalizeCheckpointRequest): unknown {
    const obj: any = {};
    if (message.checkpointId !== undefined) {
      obj.checkpointId = ChannelMarkerIdentity.toJSON(message.checkpointId);
    }
    if (message.writeTo !== "") {
      obj.writeTo = message.writeTo;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FinalizeCheckpointRequest>, I>>(base?: I): FinalizeCheckpointRequest {
    return FinalizeCheckpointRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FinalizeCheckpointRequest>, I>>(object: I): FinalizeCheckpointRequest {
    const message = createBaseFinalizeCheckpointRequest();
    message.checkpointId = (object.checkpointId !== undefined && object.checkpointId !== null)
      ? ChannelMarkerIdentity.fromPartial(object.checkpointId)
      : undefined;
    message.writeTo = object.writeTo ?? "";
    return message;
  },
};

function createBaseInitializeExecutorRequest(): InitializeExecutorRequest {
  return { totalWorkerCount: 0, opExecInitInfo: undefined, isSource: false, language: "" };
}

export const InitializeExecutorRequest: MessageFns<InitializeExecutorRequest> = {
  encode(message: InitializeExecutorRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.totalWorkerCount !== 0) {
      writer.uint32(8).int32(message.totalWorkerCount);
    }
    if (message.opExecInitInfo !== undefined) {
      Any.encode(message.opExecInitInfo, writer.uint32(18).fork()).join();
    }
    if (message.isSource !== false) {
      writer.uint32(24).bool(message.isSource);
    }
    if (message.language !== "") {
      writer.uint32(34).string(message.language);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): InitializeExecutorRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseInitializeExecutorRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 8) {
            break;
          }

          message.totalWorkerCount = reader.int32();
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.opExecInitInfo = Any.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 24) {
            break;
          }

          message.isSource = reader.bool();
          continue;
        case 4:
          if (tag !== 34) {
            break;
          }

          message.language = reader.string();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): InitializeExecutorRequest {
    return {
      totalWorkerCount: isSet(object.totalWorkerCount) ? globalThis.Number(object.totalWorkerCount) : 0,
      opExecInitInfo: isSet(object.opExecInitInfo) ? Any.fromJSON(object.opExecInitInfo) : undefined,
      isSource: isSet(object.isSource) ? globalThis.Boolean(object.isSource) : false,
      language: isSet(object.language) ? globalThis.String(object.language) : "",
    };
  },

  toJSON(message: InitializeExecutorRequest): unknown {
    const obj: any = {};
    if (message.totalWorkerCount !== 0) {
      obj.totalWorkerCount = Math.round(message.totalWorkerCount);
    }
    if (message.opExecInitInfo !== undefined) {
      obj.opExecInitInfo = Any.toJSON(message.opExecInitInfo);
    }
    if (message.isSource !== false) {
      obj.isSource = message.isSource;
    }
    if (message.language !== "") {
      obj.language = message.language;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<InitializeExecutorRequest>, I>>(base?: I): InitializeExecutorRequest {
    return InitializeExecutorRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<InitializeExecutorRequest>, I>>(object: I): InitializeExecutorRequest {
    const message = createBaseInitializeExecutorRequest();
    message.totalWorkerCount = object.totalWorkerCount ?? 0;
    message.opExecInitInfo = (object.opExecInitInfo !== undefined && object.opExecInitInfo !== null)
      ? Any.fromPartial(object.opExecInitInfo)
      : undefined;
    message.isSource = object.isSource ?? false;
    message.language = object.language ?? "";
    return message;
  },
};

function createBaseUpdateExecutorRequest(): UpdateExecutorRequest {
  return { targetOpId: undefined, newExecutor: undefined, stateTransferFunc: undefined };
}

export const UpdateExecutorRequest: MessageFns<UpdateExecutorRequest> = {
  encode(message: UpdateExecutorRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.targetOpId !== undefined) {
      PhysicalOpIdentity.encode(message.targetOpId, writer.uint32(10).fork()).join();
    }
    if (message.newExecutor !== undefined) {
      Any.encode(message.newExecutor, writer.uint32(18).fork()).join();
    }
    if (message.stateTransferFunc !== undefined) {
      Any.encode(message.stateTransferFunc, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateExecutorRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateExecutorRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.targetOpId = PhysicalOpIdentity.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 18) {
            break;
          }

          message.newExecutor = Any.decode(reader, reader.uint32());
          continue;
        case 3:
          if (tag !== 26) {
            break;
          }

          message.stateTransferFunc = Any.decode(reader, reader.uint32());
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateExecutorRequest {
    return {
      targetOpId: isSet(object.targetOpId) ? PhysicalOpIdentity.fromJSON(object.targetOpId) : undefined,
      newExecutor: isSet(object.newExecutor) ? Any.fromJSON(object.newExecutor) : undefined,
      stateTransferFunc: isSet(object.stateTransferFunc) ? Any.fromJSON(object.stateTransferFunc) : undefined,
    };
  },

  toJSON(message: UpdateExecutorRequest): unknown {
    const obj: any = {};
    if (message.targetOpId !== undefined) {
      obj.targetOpId = PhysicalOpIdentity.toJSON(message.targetOpId);
    }
    if (message.newExecutor !== undefined) {
      obj.newExecutor = Any.toJSON(message.newExecutor);
    }
    if (message.stateTransferFunc !== undefined) {
      obj.stateTransferFunc = Any.toJSON(message.stateTransferFunc);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateExecutorRequest>, I>>(base?: I): UpdateExecutorRequest {
    return UpdateExecutorRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateExecutorRequest>, I>>(object: I): UpdateExecutorRequest {
    const message = createBaseUpdateExecutorRequest();
    message.targetOpId = (object.targetOpId !== undefined && object.targetOpId !== null)
      ? PhysicalOpIdentity.fromPartial(object.targetOpId)
      : undefined;
    message.newExecutor = (object.newExecutor !== undefined && object.newExecutor !== null)
      ? Any.fromPartial(object.newExecutor)
      : undefined;
    message.stateTransferFunc = (object.stateTransferFunc !== undefined && object.stateTransferFunc !== null)
      ? Any.fromPartial(object.stateTransferFunc)
      : undefined;
    return message;
  },
};

function createBasePrepareCheckpointRequest(): PrepareCheckpointRequest {
  return { checkpointId: undefined, estimationOnly: false };
}

export const PrepareCheckpointRequest: MessageFns<PrepareCheckpointRequest> = {
  encode(message: PrepareCheckpointRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.checkpointId !== undefined) {
      ChannelMarkerIdentity.encode(message.checkpointId, writer.uint32(10).fork()).join();
    }
    if (message.estimationOnly !== false) {
      writer.uint32(16).bool(message.estimationOnly);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): PrepareCheckpointRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBasePrepareCheckpointRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.checkpointId = ChannelMarkerIdentity.decode(reader, reader.uint32());
          continue;
        case 2:
          if (tag !== 16) {
            break;
          }

          message.estimationOnly = reader.bool();
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): PrepareCheckpointRequest {
    return {
      checkpointId: isSet(object.checkpointId) ? ChannelMarkerIdentity.fromJSON(object.checkpointId) : undefined,
      estimationOnly: isSet(object.estimationOnly) ? globalThis.Boolean(object.estimationOnly) : false,
    };
  },

  toJSON(message: PrepareCheckpointRequest): unknown {
    const obj: any = {};
    if (message.checkpointId !== undefined) {
      obj.checkpointId = ChannelMarkerIdentity.toJSON(message.checkpointId);
    }
    if (message.estimationOnly !== false) {
      obj.estimationOnly = message.estimationOnly;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<PrepareCheckpointRequest>, I>>(base?: I): PrepareCheckpointRequest {
    return PrepareCheckpointRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<PrepareCheckpointRequest>, I>>(object: I): PrepareCheckpointRequest {
    const message = createBasePrepareCheckpointRequest();
    message.checkpointId = (object.checkpointId !== undefined && object.checkpointId !== null)
      ? ChannelMarkerIdentity.fromPartial(object.checkpointId)
      : undefined;
    message.estimationOnly = object.estimationOnly ?? false;
    return message;
  },
};

function createBaseQueryStatisticsRequest(): QueryStatisticsRequest {
  return { filterByWorkers: [] };
}

export const QueryStatisticsRequest: MessageFns<QueryStatisticsRequest> = {
  encode(message: QueryStatisticsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.filterByWorkers) {
      ActorVirtualIdentity.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): QueryStatisticsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseQueryStatisticsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1:
          if (tag !== 10) {
            break;
          }

          message.filterByWorkers.push(ActorVirtualIdentity.decode(reader, reader.uint32()));
          continue;
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): QueryStatisticsRequest {
    return {
      filterByWorkers: globalThis.Array.isArray(object?.filterByWorkers)
        ? object.filterByWorkers.map((e: any) => ActorVirtualIdentity.fromJSON(e))
        : [],
    };
  },

  toJSON(message: QueryStatisticsRequest): unknown {
    const obj: any = {};
    if (message.filterByWorkers?.length) {
      obj.filterByWorkers = message.filterByWorkers.map((e) => ActorVirtualIdentity.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<QueryStatisticsRequest>, I>>(base?: I): QueryStatisticsRequest {
    return QueryStatisticsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<QueryStatisticsRequest>, I>>(object: I): QueryStatisticsRequest {
    const message = createBaseQueryStatisticsRequest();
    message.filterByWorkers = object.filterByWorkers?.map((e) => ActorVirtualIdentity.fromPartial(e)) || [];
    return message;
  },
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function toTimestamp(date: Date): Timestamp {
  const seconds = Math.trunc(date.getTime() / 1_000);
  const nanos = (date.getTime() % 1_000) * 1_000_000;
  return { seconds, nanos };
}

function fromTimestamp(t: Timestamp): Date {
  let millis = (t.seconds || 0) * 1_000;
  millis += (t.nanos || 0) / 1_000_000;
  return new globalThis.Date(millis);
}

function fromJsonTimestamp(o: any): Date {
  if (o instanceof globalThis.Date) {
    return o;
  } else if (typeof o === "string") {
    return new globalThis.Date(o);
  } else {
    return fromTimestamp(Timestamp.fromJSON(o));
  }
}

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
