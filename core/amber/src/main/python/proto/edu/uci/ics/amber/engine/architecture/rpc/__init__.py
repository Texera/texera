# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: edu/uci/ics/amber/engine/architecture/rpc/controlcommands.proto, edu/uci/ics/amber/engine/architecture/rpc/controllerservice.proto, edu/uci/ics/amber/engine/architecture/rpc/controlreturns.proto, edu/uci/ics/amber/engine/architecture/rpc/testerservice.proto, edu/uci/ics/amber/engine/architecture/rpc/workerservice.proto
# plugin: python-betterproto
from dataclasses import dataclass
from datetime import datetime
from typing import Dict, List, Optional

import betterproto
from betterproto.grpc.grpclib_server import ServiceBase
import grpclib


class ChannelMarkerType(betterproto.Enum):
    """Enum for ChannelMarkerType"""

    REQUIRE_ALIGNMENT = 0
    NO_ALIGNMENT = 1


class ConsoleMessageType(betterproto.Enum):
    PRINT = 0
    ERROR = 1
    COMMAND = 2
    DEBUGGER = 3


class ErrorLanguage(betterproto.Enum):
    PYTHON = 0
    SCALA = 1


class WorkflowAggregatedState(betterproto.Enum):
    UNINITIALIZED = 0
    READY = 1
    RUNNING = 2
    PAUSING = 3
    PAUSED = 4
    RESUMING = 5
    COMPLETED = 6
    FAILED = 7
    UNKNOWN = 8
    KILLED = 9


@dataclass(eq=False, repr=False)
class ControlRequest(betterproto.Message):
    propagate_channel_marker_request: "PropagateChannelMarkerRequest" = (
        betterproto.message_field(1, group="sealed_value")
    )
    take_global_checkpoint_request: "TakeGlobalCheckpointRequest" = (
        betterproto.message_field(2, group="sealed_value")
    )
    debug_command_request: "DebugCommandRequest" = betterproto.message_field(
        3, group="sealed_value"
    )
    evaluate_python_expression_request: "EvaluatePythonExpressionRequest" = (
        betterproto.message_field(4, group="sealed_value")
    )
    modify_logic_request: "ModifyLogicRequest" = betterproto.message_field(
        5, group="sealed_value"
    )
    retry_workflow_request: "RetryWorkflowRequest" = betterproto.message_field(
        6, group="sealed_value"
    )
    console_message_triggered_request: "ConsoleMessageTriggeredRequest" = (
        betterproto.message_field(8, group="sealed_value")
    )
    port_completed_request: "PortCompletedRequest" = betterproto.message_field(
        9, group="sealed_value"
    )
    worker_state_updated_request: "WorkerStateUpdatedRequest" = (
        betterproto.message_field(13, group="sealed_value")
    )
    link_workers_request: "LinkWorkersRequest" = betterproto.message_field(
        15, group="sealed_value"
    )
    ping: "Ping" = betterproto.message_field(16, group="sealed_value")
    pong: "Pong" = betterproto.message_field(17, group="sealed_value")
    nested: "Nested" = betterproto.message_field(18, group="sealed_value")
    pass_: "Pass" = betterproto.message_field(19, group="sealed_value")
    error_command: "ErrorCommand" = betterproto.message_field(20, group="sealed_value")
    recursion: "Recursion" = betterproto.message_field(21, group="sealed_value")
    collect: "Collect" = betterproto.message_field(22, group="sealed_value")
    generate_number: "GenerateNumber" = betterproto.message_field(
        23, group="sealed_value"
    )
    multi_call: "MultiCall" = betterproto.message_field(24, group="sealed_value")
    chain: "Chain" = betterproto.message_field(25, group="sealed_value")
    add_input_channel_request: "AddInputChannelRequest" = betterproto.message_field(
        26, group="sealed_value"
    )
    add_partitioning_request: "AddPartitioningRequest" = betterproto.message_field(
        27, group="sealed_value"
    )
    assign_port_request: "AssignPortRequest" = betterproto.message_field(
        28, group="sealed_value"
    )
    finalize_checkpoint_request: "FinalizeCheckpointRequest" = (
        betterproto.message_field(29, group="sealed_value")
    )
    initialize_executor_request: "InitializeExecutorRequest" = (
        betterproto.message_field(30, group="sealed_value")
    )
    update_executor_request: "UpdateExecutorRequest" = betterproto.message_field(
        31, group="sealed_value"
    )
    empty_request: "EmptyRequest" = betterproto.message_field(33, group="sealed_value")
    prepare_checkpoint_request: "PrepareCheckpointRequest" = betterproto.message_field(
        34, group="sealed_value"
    )
    query_statistics_request: "QueryStatisticsRequest" = betterproto.message_field(
        35, group="sealed_value"
    )


@dataclass(eq=False, repr=False)
class EmptyRequest(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class AsyncRpcContext(betterproto.Message):
    sender: "__common__.ActorVirtualIdentity" = betterproto.message_field(1)
    receiver: "__common__.ActorVirtualIdentity" = betterproto.message_field(2)


@dataclass(eq=False, repr=False)
class ControlInvocation(betterproto.Message):
    method_name: str = betterproto.string_field(1)
    command: "ControlRequest" = betterproto.message_field(2)
    context: "AsyncRpcContext" = betterproto.message_field(3)
    command_id: int = betterproto.int64_field(4)


@dataclass(eq=False, repr=False)
class ChannelMarkerPayload(betterproto.Message):
    """Message for ChannelMarkerPayload"""

    id: "__common__.ChannelMarkerIdentity" = betterproto.message_field(1)
    marker_type: "ChannelMarkerType" = betterproto.enum_field(2)
    scope: List["__common__.ChannelIdentity"] = betterproto.message_field(3)
    command_mapping: Dict[str, "ControlInvocation"] = betterproto.map_field(
        4, betterproto.TYPE_STRING, betterproto.TYPE_MESSAGE
    )


@dataclass(eq=False, repr=False)
class PropagateChannelMarkerRequest(betterproto.Message):
    source_op_to_start_prop: List["__common__.PhysicalOpIdentity"] = (
        betterproto.message_field(1)
    )
    id: "__common__.ChannelMarkerIdentity" = betterproto.message_field(2)
    marker_type: "ChannelMarkerType" = betterproto.enum_field(3)
    scope: List["__common__.PhysicalOpIdentity"] = betterproto.message_field(4)
    target_ops: List["__common__.PhysicalOpIdentity"] = betterproto.message_field(5)
    marker_command: "ControlRequest" = betterproto.message_field(6)
    marker_method_name: str = betterproto.string_field(7)


@dataclass(eq=False, repr=False)
class TakeGlobalCheckpointRequest(betterproto.Message):
    estimation_only: bool = betterproto.bool_field(1)
    checkpoint_id: "__common__.ChannelMarkerIdentity" = betterproto.message_field(2)
    destination: str = betterproto.string_field(3)


@dataclass(eq=False, repr=False)
class WorkflowReconfigureRequest(betterproto.Message):
    reconfiguration: "ModifyLogicRequest" = betterproto.message_field(1)
    reconfiguration_id: str = betterproto.string_field(2)


@dataclass(eq=False, repr=False)
class DebugCommandRequest(betterproto.Message):
    worker_id: str = betterproto.string_field(1)
    cmd: str = betterproto.string_field(2)


@dataclass(eq=False, repr=False)
class EvaluatePythonExpressionRequest(betterproto.Message):
    expression: str = betterproto.string_field(1)
    operator_id: str = betterproto.string_field(2)


@dataclass(eq=False, repr=False)
class ModifyLogicRequest(betterproto.Message):
    update_request: List["UpdateExecutorRequest"] = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class RetryWorkflowRequest(betterproto.Message):
    workers: List["__common__.ActorVirtualIdentity"] = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class ConsoleMessage(betterproto.Message):
    worker_id: str = betterproto.string_field(1)
    timestamp: datetime = betterproto.message_field(2)
    msg_type: "ConsoleMessageType" = betterproto.enum_field(3)
    source: str = betterproto.string_field(4)
    title: str = betterproto.string_field(5)
    message: str = betterproto.string_field(6)


@dataclass(eq=False, repr=False)
class ConsoleMessageTriggeredRequest(betterproto.Message):
    console_message: "ConsoleMessage" = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class PortCompletedRequest(betterproto.Message):
    port_id: "__common__.PortIdentity" = betterproto.message_field(1)
    input: bool = betterproto.bool_field(2)


@dataclass(eq=False, repr=False)
class WorkerStateUpdatedRequest(betterproto.Message):
    state: "_worker__.WorkerState" = betterproto.enum_field(1)


@dataclass(eq=False, repr=False)
class LinkWorkersRequest(betterproto.Message):
    link: "__common__.PhysicalLink" = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class Ping(betterproto.Message):
    """Ping message"""

    i: int = betterproto.int32_field(1)
    end: int = betterproto.int32_field(2)
    to: "__common__.ActorVirtualIdentity" = betterproto.message_field(3)


@dataclass(eq=False, repr=False)
class Pong(betterproto.Message):
    """Pong message"""

    i: int = betterproto.int32_field(1)
    end: int = betterproto.int32_field(2)
    to: "__common__.ActorVirtualIdentity" = betterproto.message_field(3)


@dataclass(eq=False, repr=False)
class Pass(betterproto.Message):
    """Pass message"""

    value: str = betterproto.string_field(1)


@dataclass(eq=False, repr=False)
class Nested(betterproto.Message):
    """Nested message"""

    k: int = betterproto.int32_field(1)


@dataclass(eq=False, repr=False)
class MultiCall(betterproto.Message):
    """MultiCall message"""

    seq: List["__common__.ActorVirtualIdentity"] = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class ErrorCommand(betterproto.Message):
    """ErrorCommand message"""

    pass


@dataclass(eq=False, repr=False)
class Collect(betterproto.Message):
    """Collect message"""

    workers: List["__common__.ActorVirtualIdentity"] = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class GenerateNumber(betterproto.Message):
    """GenerateNumber message"""

    pass


@dataclass(eq=False, repr=False)
class Chain(betterproto.Message):
    """Chain message"""

    nexts: List["__common__.ActorVirtualIdentity"] = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class Recursion(betterproto.Message):
    """Recursion message"""

    i: int = betterproto.int32_field(1)


@dataclass(eq=False, repr=False)
class AddInputChannelRequest(betterproto.Message):
    """Messages for the commands"""

    channel_id: "__common__.ChannelIdentity" = betterproto.message_field(1)
    port_id: "__common__.PortIdentity" = betterproto.message_field(2)


@dataclass(eq=False, repr=False)
class AddPartitioningRequest(betterproto.Message):
    tag: "__common__.PhysicalLink" = betterproto.message_field(1)
    partitioning: "_sendsemantics__.Partitioning" = betterproto.message_field(2)


@dataclass(eq=False, repr=False)
class AssignPortRequest(betterproto.Message):
    port_id: "__common__.PortIdentity" = betterproto.message_field(1)
    input: bool = betterproto.bool_field(2)
    schema: Dict[str, str] = betterproto.map_field(
        3, betterproto.TYPE_STRING, betterproto.TYPE_STRING
    )


@dataclass(eq=False, repr=False)
class FinalizeCheckpointRequest(betterproto.Message):
    checkpoint_id: "__common__.ChannelMarkerIdentity" = betterproto.message_field(1)
    write_to: str = betterproto.string_field(2)


@dataclass(eq=False, repr=False)
class InitializeExecutorRequest(betterproto.Message):
    total_worker_count: int = betterproto.int32_field(1)
    op_exec_init_info: "betterproto_lib_google_protobuf.Any" = (
        betterproto.message_field(2)
    )
    is_source: bool = betterproto.bool_field(3)
    language: str = betterproto.string_field(4)


@dataclass(eq=False, repr=False)
class UpdateExecutorRequest(betterproto.Message):
    target_op_id: "__common__.PhysicalOpIdentity" = betterproto.message_field(1)
    new_executor: "betterproto_lib_google_protobuf.Any" = betterproto.message_field(2)
    state_transfer_func: "betterproto_lib_google_protobuf.Any" = (
        betterproto.message_field(3)
    )


@dataclass(eq=False, repr=False)
class PrepareCheckpointRequest(betterproto.Message):
    checkpoint_id: "__common__.ChannelMarkerIdentity" = betterproto.message_field(1)
    estimation_only: bool = betterproto.bool_field(2)


@dataclass(eq=False, repr=False)
class QueryStatisticsRequest(betterproto.Message):
    filter_by_workers: List["__common__.ActorVirtualIdentity"] = (
        betterproto.message_field(1)
    )


@dataclass(eq=False, repr=False)
class ControlReturn(betterproto.Message):
    """The generic return message"""

    error: "ControlError" = betterproto.message_field(1, group="sealed_value")
    empty_return: "EmptyReturn" = betterproto.message_field(2, group="sealed_value")
    retrieve_workflow_state_response: "RetrieveWorkflowStateResponse" = (
        betterproto.message_field(3, group="sealed_value")
    )
    propagate_channel_marker_response: "PropagateChannelMarkerResponse" = (
        betterproto.message_field(4, group="sealed_value")
    )
    take_global_checkpoint_response: "TakeGlobalCheckpointResponse" = (
        betterproto.message_field(5, group="sealed_value")
    )
    evaluate_python_expression_response: "EvaluatePythonExpressionResponse" = (
        betterproto.message_field(6, group="sealed_value")
    )
    start_workflow_response: "StartWorkflowResponse" = betterproto.message_field(
        7, group="sealed_value"
    )
    string_response: "StringResponse" = betterproto.message_field(
        8, group="sealed_value"
    )
    int_response: "IntResponse" = betterproto.message_field(9, group="sealed_value")
    worker_state_response: "WorkerStateResponse" = betterproto.message_field(
        10, group="sealed_value"
    )
    worker_metrics_response: "WorkerMetricsResponse" = betterproto.message_field(
        11, group="sealed_value"
    )
    finalize_checkpoint_response: "FinalizeCheckpointResponse" = (
        betterproto.message_field(12, group="sealed_value")
    )


@dataclass(eq=False, repr=False)
class EmptyReturn(betterproto.Message):
    pass


@dataclass(eq=False, repr=False)
class ControlError(betterproto.Message):
    error_message: str = betterproto.string_field(1)
    error_details: str = betterproto.string_field(2)
    stack_trace: str = betterproto.string_field(3)
    language: "ErrorLanguage" = betterproto.enum_field(4)


@dataclass(eq=False, repr=False)
class ReturnInvocation(betterproto.Message):
    command_id: int = betterproto.int64_field(1)
    return_value: "ControlReturn" = betterproto.message_field(2)


@dataclass(eq=False, repr=False)
class StringResponse(betterproto.Message):
    value: str = betterproto.string_field(1)


@dataclass(eq=False, repr=False)
class IntResponse(betterproto.Message):
    value: int = betterproto.int32_field(1)


@dataclass(eq=False, repr=False)
class RetrieveWorkflowStateResponse(betterproto.Message):
    state: Dict[str, str] = betterproto.map_field(
        1, betterproto.TYPE_STRING, betterproto.TYPE_STRING
    )


@dataclass(eq=False, repr=False)
class FinalizeCheckpointResponse(betterproto.Message):
    size: int = betterproto.int64_field(1)


@dataclass(eq=False, repr=False)
class PropagateChannelMarkerResponse(betterproto.Message):
    returns: Dict[str, "ControlReturn"] = betterproto.map_field(
        1, betterproto.TYPE_STRING, betterproto.TYPE_MESSAGE
    )


@dataclass(eq=False, repr=False)
class TakeGlobalCheckpointResponse(betterproto.Message):
    total_size: int = betterproto.int64_field(1)


@dataclass(eq=False, repr=False)
class TypedValue(betterproto.Message):
    expression: str = betterproto.string_field(1)
    value_ref: str = betterproto.string_field(2)
    value_str: str = betterproto.string_field(3)
    value_type: str = betterproto.string_field(4)
    expandable: bool = betterproto.bool_field(5)


@dataclass(eq=False, repr=False)
class EvaluatedValue(betterproto.Message):
    value: "TypedValue" = betterproto.message_field(1)
    attributes: List["TypedValue"] = betterproto.message_field(2)


@dataclass(eq=False, repr=False)
class EvaluatePythonExpressionResponse(betterproto.Message):
    values: List["EvaluatedValue"] = betterproto.message_field(1)


@dataclass(eq=False, repr=False)
class StartWorkflowResponse(betterproto.Message):
    workflow_state: "WorkflowAggregatedState" = betterproto.enum_field(1)


@dataclass(eq=False, repr=False)
class WorkerStateResponse(betterproto.Message):
    state: "_worker__.WorkerState" = betterproto.enum_field(1)


@dataclass(eq=False, repr=False)
class WorkerMetricsResponse(betterproto.Message):
    metrics: "_worker__.WorkerMetrics" = betterproto.message_field(1)


class RpcTesterStub(betterproto.ServiceStub):
    async def send_ping(
        self, *, i: int = 0, end: int = 0, to: "__common__.ActorVirtualIdentity" = None
    ) -> "IntResponse":

        request = Ping()
        request.i = i
        request.end = end
        if to is not None:
            request.to = to

        return await self._unary_unary(
            "/edu.uci.ics.amber.engine.architecture.rpc.RPCTester/SendPing",
            request,
            IntResponse,
        )

    async def send_pong(
        self, *, i: int = 0, end: int = 0, to: "__common__.ActorVirtualIdentity" = None
    ) -> "IntResponse":

        request = Pong()
        request.i = i
        request.end = end
        if to is not None:
            request.to = to

        return await self._unary_unary(
            "/edu.uci.ics.amber.engine.architecture.rpc.RPCTester/SendPong",
            request,
            IntResponse,
        )

    async def send_nested(self, *, k: int = 0) -> "StringResponse":

        request = Nested()
        request.k = k

        return await self._unary_unary(
            "/edu.uci.ics.amber.engine.architecture.rpc.RPCTester/SendNested",
            request,
            StringResponse,
        )

    async def send_pass(self, *, value: str = "") -> "StringResponse":

        request = Pass()
        request.value = value

        return await self._unary_unary(
            "/edu.uci.ics.amber.engine.architecture.rpc.RPCTester/SendPass",
            request,
            StringResponse,
        )

    async def send_error_command(self) -> "StringResponse":

        request = ErrorCommand()

        return await self._unary_unary(
            "/edu.uci.ics.amber.engine.architecture.rpc.RPCTester/SendErrorCommand",
            request,
            StringResponse,
        )

    async def send_recursion(self, *, i: int = 0) -> "StringResponse":

        request = Recursion()
        request.i = i

        return await self._unary_unary(
            "/edu.uci.ics.amber.engine.architecture.rpc.RPCTester/SendRecursion",
            request,
            StringResponse,
        )

    async def send_collect(
        self, *, workers: Optional[List["__common__.ActorVirtualIdentity"]] = None
    ) -> "StringResponse":
        workers = workers or []

        request = Collect()
        if workers is not None:
            request.workers = workers

        return await self._unary_unary(
            "/edu.uci.ics.amber.engine.architecture.rpc.RPCTester/SendCollect",
            request,
            StringResponse,
        )

    async def send_generate_number(self) -> "IntResponse":

        request = GenerateNumber()

        return await self._unary_unary(
            "/edu.uci.ics.amber.engine.architecture.rpc.RPCTester/SendGenerateNumber",
            request,
            IntResponse,
        )

    async def send_multi_call(
        self, *, seq: Optional[List["__common__.ActorVirtualIdentity"]] = None
    ) -> "StringResponse":
        seq = seq or []

        request = MultiCall()
        if seq is not None:
            request.seq = seq

        return await self._unary_unary(
            "/edu.uci.ics.amber.engine.architecture.rpc.RPCTester/SendMultiCall",
            request,
            StringResponse,
        )

    async def send_chain(
        self, *, nexts: Optional[List["__common__.ActorVirtualIdentity"]] = None
    ) -> "StringResponse":
        nexts = nexts or []

        request = Chain()
        if nexts is not None:
            request.nexts = nexts

        return await self._unary_unary(
            "/edu.uci.ics.amber.engine.architecture.rpc.RPCTester/SendChain",
            request,
            StringResponse,
        )


class WorkerServiceStub(betterproto.ServiceStub):
    async def add_input_channel(
        self,
        *,
        channel_id: "__common__.ChannelIdentity" = None,
        port_id: "__common__.PortIdentity" = None,
    ) -> "EmptyReturn":

        request = AddInputChannelRequest()
        if channel_id is not None:
            request.channel_id = channel_id
        if port_id is not None:
            request.port_id = port_id

        return await self._unary_unary(
            "/edu.uci.ics.amber.engine.architecture.rpc.WorkerService/AddInputChannel",
            request,
            EmptyReturn,
        )

    async def add_partitioning(
        self,
        *,
        tag: "__common__.PhysicalLink" = None,
        partitioning: "_sendsemantics__.Partitioning" = None,
    ) -> "EmptyReturn":

        request = AddPartitioningRequest()
        if tag is not None:
            request.tag = tag
        if partitioning is not None:
            request.partitioning = partitioning

        return await self._unary_unary(
            "/edu.uci.ics.amber.engine.architecture.rpc.WorkerService/AddPartitioning",
            request,
            EmptyReturn,
        )

    async def assign_port(
        self,
        *,
        port_id: "__common__.PortIdentity" = None,
        input: bool = False,
        schema: Dict[str, str] = None,
    ) -> "EmptyReturn":

        request = AssignPortRequest()
        if port_id is not None:
            request.port_id = port_id
        request.input = input
        request.schema = schema

        return await self._unary_unary(
            "/edu.uci.ics.amber.engine.architecture.rpc.WorkerService/AssignPort",
            request,
            EmptyReturn,
        )

    async def finalize_checkpoint(
        self,
        *,
        checkpoint_id: "__common__.ChannelMarkerIdentity" = None,
        write_to: str = "",
    ) -> "FinalizeCheckpointResponse":

        request = FinalizeCheckpointRequest()
        if checkpoint_id is not None:
            request.checkpoint_id = checkpoint_id
        request.write_to = write_to

        return await self._unary_unary(
            "/edu.uci.ics.amber.engine.architecture.rpc.WorkerService/FinalizeCheckpoint",
            request,
            FinalizeCheckpointResponse,
        )

    async def flush_network_buffer(self) -> "EmptyReturn":

        request = EmptyRequest()

        return await self._unary_unary(
            "/edu.uci.ics.amber.engine.architecture.rpc.WorkerService/FlushNetworkBuffer",
            request,
            EmptyReturn,
        )

    async def initialize_executor(
        self,
        *,
        total_worker_count: int = 0,
        op_exec_init_info: "betterproto_lib_google_protobuf.Any" = None,
        is_source: bool = False,
        language: str = "",
    ) -> "EmptyReturn":

        request = InitializeExecutorRequest()
        request.total_worker_count = total_worker_count
        if op_exec_init_info is not None:
            request.op_exec_init_info = op_exec_init_info
        request.is_source = is_source
        request.language = language

        return await self._unary_unary(
            "/edu.uci.ics.amber.engine.architecture.rpc.WorkerService/InitializeExecutor",
            request,
            EmptyReturn,
        )

    async def open_executor(self) -> "EmptyReturn":

        request = EmptyRequest()

        return await self._unary_unary(
            "/edu.uci.ics.amber.engine.architecture.rpc.WorkerService/OpenExecutor",
            request,
            EmptyReturn,
        )

    async def pause_worker(self) -> "WorkerStateResponse":

        request = EmptyRequest()

        return await self._unary_unary(
            "/edu.uci.ics.amber.engine.architecture.rpc.WorkerService/PauseWorker",
            request,
            WorkerStateResponse,
        )

    async def prepare_checkpoint(
        self,
        *,
        checkpoint_id: "__common__.ChannelMarkerIdentity" = None,
        estimation_only: bool = False,
    ) -> "EmptyReturn":

        request = PrepareCheckpointRequest()
        if checkpoint_id is not None:
            request.checkpoint_id = checkpoint_id
        request.estimation_only = estimation_only

        return await self._unary_unary(
            "/edu.uci.ics.amber.engine.architecture.rpc.WorkerService/PrepareCheckpoint",
            request,
            EmptyReturn,
        )

    async def query_statistics(self) -> "WorkerMetricsResponse":

        request = EmptyRequest()

        return await self._unary_unary(
            "/edu.uci.ics.amber.engine.architecture.rpc.WorkerService/QueryStatistics",
            request,
            WorkerMetricsResponse,
        )

    async def resume_worker(self) -> "WorkerStateResponse":

        request = EmptyRequest()

        return await self._unary_unary(
            "/edu.uci.ics.amber.engine.architecture.rpc.WorkerService/ResumeWorker",
            request,
            WorkerStateResponse,
        )

    async def retrieve_state(self) -> "EmptyReturn":

        request = EmptyRequest()

        return await self._unary_unary(
            "/edu.uci.ics.amber.engine.architecture.rpc.WorkerService/RetrieveState",
            request,
            EmptyReturn,
        )

    async def retry_current_tuple(self) -> "EmptyReturn":

        request = EmptyRequest()

        return await self._unary_unary(
            "/edu.uci.ics.amber.engine.architecture.rpc.WorkerService/RetryCurrentTuple",
            request,
            EmptyReturn,
        )

    async def start_worker(self) -> "WorkerStateResponse":

        request = EmptyRequest()

        return await self._unary_unary(
            "/edu.uci.ics.amber.engine.architecture.rpc.WorkerService/StartWorker",
            request,
            WorkerStateResponse,
        )

    async def modify_logic(
        self, *, update_request: Optional[List["UpdateExecutorRequest"]] = None
    ) -> "EmptyReturn":
        update_request = update_request or []

        request = ModifyLogicRequest()
        if update_request is not None:
            request.update_request = update_request

        return await self._unary_unary(
            "/edu.uci.ics.amber.engine.architecture.rpc.WorkerService/ModifyLogic",
            request,
            EmptyReturn,
        )

    async def debug_command(
        self, *, worker_id: str = "", cmd: str = ""
    ) -> "EmptyReturn":

        request = DebugCommandRequest()
        request.worker_id = worker_id
        request.cmd = cmd

        return await self._unary_unary(
            "/edu.uci.ics.amber.engine.architecture.rpc.WorkerService/DebugCommand",
            request,
            EmptyReturn,
        )

    async def evaluate_python_expression(
        self, *, expression: str = "", operator_id: str = ""
    ) -> "EvaluatedValue":

        request = EvaluatePythonExpressionRequest()
        request.expression = expression
        request.operator_id = operator_id

        return await self._unary_unary(
            "/edu.uci.ics.amber.engine.architecture.rpc.WorkerService/EvaluatePythonExpression",
            request,
            EvaluatedValue,
        )


class ControllerServiceStub(betterproto.ServiceStub):
    async def retrieve_workflow_state(self) -> "RetrieveWorkflowStateResponse":

        request = EmptyRequest()

        return await self._unary_unary(
            "/edu.uci.ics.amber.engine.architecture.rpc.ControllerService/RetrieveWorkflowState",
            request,
            RetrieveWorkflowStateResponse,
        )

    async def propagate_channel_marker(
        self,
        *,
        source_op_to_start_prop: Optional[List["__common__.PhysicalOpIdentity"]] = None,
        id: "__common__.ChannelMarkerIdentity" = None,
        marker_type: "ChannelMarkerType" = None,
        scope: Optional[List["__common__.PhysicalOpIdentity"]] = None,
        target_ops: Optional[List["__common__.PhysicalOpIdentity"]] = None,
        marker_command: "ControlRequest" = None,
        marker_method_name: str = "",
    ) -> "PropagateChannelMarkerResponse":
        source_op_to_start_prop = source_op_to_start_prop or []
        scope = scope or []
        target_ops = target_ops or []

        request = PropagateChannelMarkerRequest()
        if source_op_to_start_prop is not None:
            request.source_op_to_start_prop = source_op_to_start_prop
        if id is not None:
            request.id = id
        request.marker_type = marker_type
        if scope is not None:
            request.scope = scope
        if target_ops is not None:
            request.target_ops = target_ops
        if marker_command is not None:
            request.marker_command = marker_command
        request.marker_method_name = marker_method_name

        return await self._unary_unary(
            "/edu.uci.ics.amber.engine.architecture.rpc.ControllerService/PropagateChannelMarker",
            request,
            PropagateChannelMarkerResponse,
        )

    async def take_global_checkpoint(
        self,
        *,
        estimation_only: bool = False,
        checkpoint_id: "__common__.ChannelMarkerIdentity" = None,
        destination: str = "",
    ) -> "TakeGlobalCheckpointResponse":

        request = TakeGlobalCheckpointRequest()
        request.estimation_only = estimation_only
        if checkpoint_id is not None:
            request.checkpoint_id = checkpoint_id
        request.destination = destination

        return await self._unary_unary(
            "/edu.uci.ics.amber.engine.architecture.rpc.ControllerService/TakeGlobalCheckpoint",
            request,
            TakeGlobalCheckpointResponse,
        )

    async def debug_command(
        self, *, worker_id: str = "", cmd: str = ""
    ) -> "EmptyReturn":

        request = DebugCommandRequest()
        request.worker_id = worker_id
        request.cmd = cmd

        return await self._unary_unary(
            "/edu.uci.ics.amber.engine.architecture.rpc.ControllerService/DebugCommand",
            request,
            EmptyReturn,
        )

    async def evaluate_python_expression(
        self, *, expression: str = "", operator_id: str = ""
    ) -> "EvaluatePythonExpressionResponse":

        request = EvaluatePythonExpressionRequest()
        request.expression = expression
        request.operator_id = operator_id

        return await self._unary_unary(
            "/edu.uci.ics.amber.engine.architecture.rpc.ControllerService/EvaluatePythonExpression",
            request,
            EvaluatePythonExpressionResponse,
        )

    async def console_message_triggered(
        self, *, console_message: "ConsoleMessage" = None
    ) -> "EmptyReturn":

        request = ConsoleMessageTriggeredRequest()
        if console_message is not None:
            request.console_message = console_message

        return await self._unary_unary(
            "/edu.uci.ics.amber.engine.architecture.rpc.ControllerService/ConsoleMessageTriggered",
            request,
            EmptyReturn,
        )

    async def port_completed(
        self, *, port_id: "__common__.PortIdentity" = None, input: bool = False
    ) -> "EmptyReturn":

        request = PortCompletedRequest()
        if port_id is not None:
            request.port_id = port_id
        request.input = input

        return await self._unary_unary(
            "/edu.uci.ics.amber.engine.architecture.rpc.ControllerService/PortCompleted",
            request,
            EmptyReturn,
        )

    async def start_workflow(self) -> "StartWorkflowResponse":

        request = EmptyRequest()

        return await self._unary_unary(
            "/edu.uci.ics.amber.engine.architecture.rpc.ControllerService/StartWorkflow",
            request,
            StartWorkflowResponse,
        )

    async def resume_workflow(self) -> "EmptyReturn":

        request = EmptyRequest()

        return await self._unary_unary(
            "/edu.uci.ics.amber.engine.architecture.rpc.ControllerService/ResumeWorkflow",
            request,
            EmptyReturn,
        )

    async def pause_workflow(self) -> "EmptyReturn":

        request = EmptyRequest()

        return await self._unary_unary(
            "/edu.uci.ics.amber.engine.architecture.rpc.ControllerService/PauseWorkflow",
            request,
            EmptyReturn,
        )

    async def worker_state_updated(
        self, *, state: "_worker__.WorkerState" = None
    ) -> "EmptyReturn":

        request = WorkerStateUpdatedRequest()
        request.state = state

        return await self._unary_unary(
            "/edu.uci.ics.amber.engine.architecture.rpc.ControllerService/WorkerStateUpdated",
            request,
            EmptyReturn,
        )

    async def worker_execution_completed(self) -> "EmptyReturn":

        request = EmptyRequest()

        return await self._unary_unary(
            "/edu.uci.ics.amber.engine.architecture.rpc.ControllerService/WorkerExecutionCompleted",
            request,
            EmptyReturn,
        )

    async def link_workers(
        self, *, link: "__common__.PhysicalLink" = None
    ) -> "EmptyReturn":

        request = LinkWorkersRequest()
        if link is not None:
            request.link = link

        return await self._unary_unary(
            "/edu.uci.ics.amber.engine.architecture.rpc.ControllerService/LinkWorkers",
            request,
            EmptyReturn,
        )

    async def controller_initiate_query_statistics(
        self,
        *,
        filter_by_workers: Optional[List["__common__.ActorVirtualIdentity"]] = None,
    ) -> "EmptyReturn":
        filter_by_workers = filter_by_workers or []

        request = QueryStatisticsRequest()
        if filter_by_workers is not None:
            request.filter_by_workers = filter_by_workers

        return await self._unary_unary(
            "/edu.uci.ics.amber.engine.architecture.rpc.ControllerService/ControllerInitiateQueryStatistics",
            request,
            EmptyReturn,
        )

    async def retry_workflow(
        self, *, workers: Optional[List["__common__.ActorVirtualIdentity"]] = None
    ) -> "EmptyReturn":
        workers = workers or []

        request = RetryWorkflowRequest()
        if workers is not None:
            request.workers = workers

        return await self._unary_unary(
            "/edu.uci.ics.amber.engine.architecture.rpc.ControllerService/RetryWorkflow",
            request,
            EmptyReturn,
        )


class RpcTesterBase(ServiceBase):

    async def send_ping(
        self, i: int, end: int, to: "__common__.ActorVirtualIdentity"
    ) -> "IntResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def send_pong(
        self, i: int, end: int, to: "__common__.ActorVirtualIdentity"
    ) -> "IntResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def send_nested(self, k: int) -> "StringResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def send_pass(self, value: str) -> "StringResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def send_error_command(self) -> "StringResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def send_recursion(self, i: int) -> "StringResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def send_collect(
        self, workers: Optional[List["__common__.ActorVirtualIdentity"]]
    ) -> "StringResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def send_generate_number(self) -> "IntResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def send_multi_call(
        self, seq: Optional[List["__common__.ActorVirtualIdentity"]]
    ) -> "StringResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def send_chain(
        self, nexts: Optional[List["__common__.ActorVirtualIdentity"]]
    ) -> "StringResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def __rpc_send_ping(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "i": request.i,
            "end": request.end,
            "to": request.to,
        }

        response = await self.send_ping(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_send_pong(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "i": request.i,
            "end": request.end,
            "to": request.to,
        }

        response = await self.send_pong(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_send_nested(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "k": request.k,
        }

        response = await self.send_nested(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_send_pass(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "value": request.value,
        }

        response = await self.send_pass(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_send_error_command(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {}

        response = await self.send_error_command(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_send_recursion(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "i": request.i,
        }

        response = await self.send_recursion(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_send_collect(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "workers": request.workers,
        }

        response = await self.send_collect(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_send_generate_number(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {}

        response = await self.send_generate_number(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_send_multi_call(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "seq": request.seq,
        }

        response = await self.send_multi_call(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_send_chain(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "nexts": request.nexts,
        }

        response = await self.send_chain(**request_kwargs)
        await stream.send_message(response)

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/edu.uci.ics.amber.engine.architecture.rpc.RPCTester/SendPing": grpclib.const.Handler(
                self.__rpc_send_ping,
                grpclib.const.Cardinality.UNARY_UNARY,
                Ping,
                IntResponse,
            ),
            "/edu.uci.ics.amber.engine.architecture.rpc.RPCTester/SendPong": grpclib.const.Handler(
                self.__rpc_send_pong,
                grpclib.const.Cardinality.UNARY_UNARY,
                Pong,
                IntResponse,
            ),
            "/edu.uci.ics.amber.engine.architecture.rpc.RPCTester/SendNested": grpclib.const.Handler(
                self.__rpc_send_nested,
                grpclib.const.Cardinality.UNARY_UNARY,
                Nested,
                StringResponse,
            ),
            "/edu.uci.ics.amber.engine.architecture.rpc.RPCTester/SendPass": grpclib.const.Handler(
                self.__rpc_send_pass,
                grpclib.const.Cardinality.UNARY_UNARY,
                Pass,
                StringResponse,
            ),
            "/edu.uci.ics.amber.engine.architecture.rpc.RPCTester/SendErrorCommand": grpclib.const.Handler(
                self.__rpc_send_error_command,
                grpclib.const.Cardinality.UNARY_UNARY,
                ErrorCommand,
                StringResponse,
            ),
            "/edu.uci.ics.amber.engine.architecture.rpc.RPCTester/SendRecursion": grpclib.const.Handler(
                self.__rpc_send_recursion,
                grpclib.const.Cardinality.UNARY_UNARY,
                Recursion,
                StringResponse,
            ),
            "/edu.uci.ics.amber.engine.architecture.rpc.RPCTester/SendCollect": grpclib.const.Handler(
                self.__rpc_send_collect,
                grpclib.const.Cardinality.UNARY_UNARY,
                Collect,
                StringResponse,
            ),
            "/edu.uci.ics.amber.engine.architecture.rpc.RPCTester/SendGenerateNumber": grpclib.const.Handler(
                self.__rpc_send_generate_number,
                grpclib.const.Cardinality.UNARY_UNARY,
                GenerateNumber,
                IntResponse,
            ),
            "/edu.uci.ics.amber.engine.architecture.rpc.RPCTester/SendMultiCall": grpclib.const.Handler(
                self.__rpc_send_multi_call,
                grpclib.const.Cardinality.UNARY_UNARY,
                MultiCall,
                StringResponse,
            ),
            "/edu.uci.ics.amber.engine.architecture.rpc.RPCTester/SendChain": grpclib.const.Handler(
                self.__rpc_send_chain,
                grpclib.const.Cardinality.UNARY_UNARY,
                Chain,
                StringResponse,
            ),
        }


class WorkerServiceBase(ServiceBase):

    async def add_input_channel(
        self,
        channel_id: "__common__.ChannelIdentity",
        port_id: "__common__.PortIdentity",
    ) -> "EmptyReturn":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def add_partitioning(
        self,
        tag: "__common__.PhysicalLink",
        partitioning: "_sendsemantics__.Partitioning",
    ) -> "EmptyReturn":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def assign_port(
        self, port_id: "__common__.PortIdentity", input: bool, schema: Dict[str, str]
    ) -> "EmptyReturn":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def finalize_checkpoint(
        self, checkpoint_id: "__common__.ChannelMarkerIdentity", write_to: str
    ) -> "FinalizeCheckpointResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def flush_network_buffer(self) -> "EmptyReturn":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def initialize_executor(
        self,
        total_worker_count: int,
        op_exec_init_info: "betterproto_lib_google_protobuf.Any",
        is_source: bool,
        language: str,
    ) -> "EmptyReturn":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def open_executor(self) -> "EmptyReturn":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def pause_worker(self) -> "WorkerStateResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def prepare_checkpoint(
        self, checkpoint_id: "__common__.ChannelMarkerIdentity", estimation_only: bool
    ) -> "EmptyReturn":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def query_statistics(self) -> "WorkerMetricsResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def resume_worker(self) -> "WorkerStateResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def retrieve_state(self) -> "EmptyReturn":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def retry_current_tuple(self) -> "EmptyReturn":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def start_worker(self) -> "WorkerStateResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def modify_logic(
        self, update_request: Optional[List["UpdateExecutorRequest"]]
    ) -> "EmptyReturn":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def debug_command(self, worker_id: str, cmd: str) -> "EmptyReturn":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def evaluate_python_expression(
        self, expression: str, operator_id: str
    ) -> "EvaluatedValue":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def __rpc_add_input_channel(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "channel_id": request.channel_id,
            "port_id": request.port_id,
        }

        response = await self.add_input_channel(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_add_partitioning(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "tag": request.tag,
            "partitioning": request.partitioning,
        }

        response = await self.add_partitioning(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_assign_port(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "port_id": request.port_id,
            "input": request.input,
            "schema": request.schema,
        }

        response = await self.assign_port(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_finalize_checkpoint(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "checkpoint_id": request.checkpoint_id,
            "write_to": request.write_to,
        }

        response = await self.finalize_checkpoint(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_flush_network_buffer(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {}

        response = await self.flush_network_buffer(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_initialize_executor(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "total_worker_count": request.total_worker_count,
            "op_exec_init_info": request.op_exec_init_info,
            "is_source": request.is_source,
            "language": request.language,
        }

        response = await self.initialize_executor(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_open_executor(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {}

        response = await self.open_executor(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_pause_worker(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {}

        response = await self.pause_worker(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_prepare_checkpoint(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "checkpoint_id": request.checkpoint_id,
            "estimation_only": request.estimation_only,
        }

        response = await self.prepare_checkpoint(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_query_statistics(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {}

        response = await self.query_statistics(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_resume_worker(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {}

        response = await self.resume_worker(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_retrieve_state(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {}

        response = await self.retrieve_state(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_retry_current_tuple(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {}

        response = await self.retry_current_tuple(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_start_worker(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {}

        response = await self.start_worker(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_modify_logic(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "update_request": request.update_request,
        }

        response = await self.modify_logic(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_debug_command(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "worker_id": request.worker_id,
            "cmd": request.cmd,
        }

        response = await self.debug_command(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_evaluate_python_expression(
        self, stream: grpclib.server.Stream
    ) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "expression": request.expression,
            "operator_id": request.operator_id,
        }

        response = await self.evaluate_python_expression(**request_kwargs)
        await stream.send_message(response)

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/edu.uci.ics.amber.engine.architecture.rpc.WorkerService/AddInputChannel": grpclib.const.Handler(
                self.__rpc_add_input_channel,
                grpclib.const.Cardinality.UNARY_UNARY,
                AddInputChannelRequest,
                EmptyReturn,
            ),
            "/edu.uci.ics.amber.engine.architecture.rpc.WorkerService/AddPartitioning": grpclib.const.Handler(
                self.__rpc_add_partitioning,
                grpclib.const.Cardinality.UNARY_UNARY,
                AddPartitioningRequest,
                EmptyReturn,
            ),
            "/edu.uci.ics.amber.engine.architecture.rpc.WorkerService/AssignPort": grpclib.const.Handler(
                self.__rpc_assign_port,
                grpclib.const.Cardinality.UNARY_UNARY,
                AssignPortRequest,
                EmptyReturn,
            ),
            "/edu.uci.ics.amber.engine.architecture.rpc.WorkerService/FinalizeCheckpoint": grpclib.const.Handler(
                self.__rpc_finalize_checkpoint,
                grpclib.const.Cardinality.UNARY_UNARY,
                FinalizeCheckpointRequest,
                FinalizeCheckpointResponse,
            ),
            "/edu.uci.ics.amber.engine.architecture.rpc.WorkerService/FlushNetworkBuffer": grpclib.const.Handler(
                self.__rpc_flush_network_buffer,
                grpclib.const.Cardinality.UNARY_UNARY,
                EmptyRequest,
                EmptyReturn,
            ),
            "/edu.uci.ics.amber.engine.architecture.rpc.WorkerService/InitializeExecutor": grpclib.const.Handler(
                self.__rpc_initialize_executor,
                grpclib.const.Cardinality.UNARY_UNARY,
                InitializeExecutorRequest,
                EmptyReturn,
            ),
            "/edu.uci.ics.amber.engine.architecture.rpc.WorkerService/OpenExecutor": grpclib.const.Handler(
                self.__rpc_open_executor,
                grpclib.const.Cardinality.UNARY_UNARY,
                EmptyRequest,
                EmptyReturn,
            ),
            "/edu.uci.ics.amber.engine.architecture.rpc.WorkerService/PauseWorker": grpclib.const.Handler(
                self.__rpc_pause_worker,
                grpclib.const.Cardinality.UNARY_UNARY,
                EmptyRequest,
                WorkerStateResponse,
            ),
            "/edu.uci.ics.amber.engine.architecture.rpc.WorkerService/PrepareCheckpoint": grpclib.const.Handler(
                self.__rpc_prepare_checkpoint,
                grpclib.const.Cardinality.UNARY_UNARY,
                PrepareCheckpointRequest,
                EmptyReturn,
            ),
            "/edu.uci.ics.amber.engine.architecture.rpc.WorkerService/QueryStatistics": grpclib.const.Handler(
                self.__rpc_query_statistics,
                grpclib.const.Cardinality.UNARY_UNARY,
                EmptyRequest,
                WorkerMetricsResponse,
            ),
            "/edu.uci.ics.amber.engine.architecture.rpc.WorkerService/ResumeWorker": grpclib.const.Handler(
                self.__rpc_resume_worker,
                grpclib.const.Cardinality.UNARY_UNARY,
                EmptyRequest,
                WorkerStateResponse,
            ),
            "/edu.uci.ics.amber.engine.architecture.rpc.WorkerService/RetrieveState": grpclib.const.Handler(
                self.__rpc_retrieve_state,
                grpclib.const.Cardinality.UNARY_UNARY,
                EmptyRequest,
                EmptyReturn,
            ),
            "/edu.uci.ics.amber.engine.architecture.rpc.WorkerService/RetryCurrentTuple": grpclib.const.Handler(
                self.__rpc_retry_current_tuple,
                grpclib.const.Cardinality.UNARY_UNARY,
                EmptyRequest,
                EmptyReturn,
            ),
            "/edu.uci.ics.amber.engine.architecture.rpc.WorkerService/StartWorker": grpclib.const.Handler(
                self.__rpc_start_worker,
                grpclib.const.Cardinality.UNARY_UNARY,
                EmptyRequest,
                WorkerStateResponse,
            ),
            "/edu.uci.ics.amber.engine.architecture.rpc.WorkerService/ModifyLogic": grpclib.const.Handler(
                self.__rpc_modify_logic,
                grpclib.const.Cardinality.UNARY_UNARY,
                ModifyLogicRequest,
                EmptyReturn,
            ),
            "/edu.uci.ics.amber.engine.architecture.rpc.WorkerService/DebugCommand": grpclib.const.Handler(
                self.__rpc_debug_command,
                grpclib.const.Cardinality.UNARY_UNARY,
                DebugCommandRequest,
                EmptyReturn,
            ),
            "/edu.uci.ics.amber.engine.architecture.rpc.WorkerService/EvaluatePythonExpression": grpclib.const.Handler(
                self.__rpc_evaluate_python_expression,
                grpclib.const.Cardinality.UNARY_UNARY,
                EvaluatePythonExpressionRequest,
                EvaluatedValue,
            ),
        }


class ControllerServiceBase(ServiceBase):

    async def retrieve_workflow_state(self) -> "RetrieveWorkflowStateResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def propagate_channel_marker(
        self,
        source_op_to_start_prop: Optional[List["__common__.PhysicalOpIdentity"]],
        id: "__common__.ChannelMarkerIdentity",
        marker_type: "ChannelMarkerType",
        scope: Optional[List["__common__.PhysicalOpIdentity"]],
        target_ops: Optional[List["__common__.PhysicalOpIdentity"]],
        marker_command: "ControlRequest",
        marker_method_name: str,
    ) -> "PropagateChannelMarkerResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def take_global_checkpoint(
        self,
        estimation_only: bool,
        checkpoint_id: "__common__.ChannelMarkerIdentity",
        destination: str,
    ) -> "TakeGlobalCheckpointResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def debug_command(self, worker_id: str, cmd: str) -> "EmptyReturn":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def evaluate_python_expression(
        self, expression: str, operator_id: str
    ) -> "EvaluatePythonExpressionResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def console_message_triggered(
        self, console_message: "ConsoleMessage"
    ) -> "EmptyReturn":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def port_completed(
        self, port_id: "__common__.PortIdentity", input: bool
    ) -> "EmptyReturn":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def start_workflow(self) -> "StartWorkflowResponse":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def resume_workflow(self) -> "EmptyReturn":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def pause_workflow(self) -> "EmptyReturn":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def worker_state_updated(
        self, state: "_worker__.WorkerState"
    ) -> "EmptyReturn":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def worker_execution_completed(self) -> "EmptyReturn":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def link_workers(self, link: "__common__.PhysicalLink") -> "EmptyReturn":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def controller_initiate_query_statistics(
        self, filter_by_workers: Optional[List["__common__.ActorVirtualIdentity"]]
    ) -> "EmptyReturn":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def retry_workflow(
        self, workers: Optional[List["__common__.ActorVirtualIdentity"]]
    ) -> "EmptyReturn":
        raise grpclib.GRPCError(grpclib.const.Status.UNIMPLEMENTED)

    async def __rpc_retrieve_workflow_state(
        self, stream: grpclib.server.Stream
    ) -> None:
        request = await stream.recv_message()

        request_kwargs = {}

        response = await self.retrieve_workflow_state(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_propagate_channel_marker(
        self, stream: grpclib.server.Stream
    ) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "source_op_to_start_prop": request.source_op_to_start_prop,
            "id": request.id,
            "marker_type": request.marker_type,
            "scope": request.scope,
            "target_ops": request.target_ops,
            "marker_command": request.marker_command,
            "marker_method_name": request.marker_method_name,
        }

        response = await self.propagate_channel_marker(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_take_global_checkpoint(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "estimation_only": request.estimation_only,
            "checkpoint_id": request.checkpoint_id,
            "destination": request.destination,
        }

        response = await self.take_global_checkpoint(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_debug_command(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "worker_id": request.worker_id,
            "cmd": request.cmd,
        }

        response = await self.debug_command(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_evaluate_python_expression(
        self, stream: grpclib.server.Stream
    ) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "expression": request.expression,
            "operator_id": request.operator_id,
        }

        response = await self.evaluate_python_expression(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_console_message_triggered(
        self, stream: grpclib.server.Stream
    ) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "console_message": request.console_message,
        }

        response = await self.console_message_triggered(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_port_completed(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "port_id": request.port_id,
            "input": request.input,
        }

        response = await self.port_completed(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_start_workflow(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {}

        response = await self.start_workflow(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_resume_workflow(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {}

        response = await self.resume_workflow(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_pause_workflow(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {}

        response = await self.pause_workflow(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_worker_state_updated(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "state": request.state,
        }

        response = await self.worker_state_updated(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_worker_execution_completed(
        self, stream: grpclib.server.Stream
    ) -> None:
        request = await stream.recv_message()

        request_kwargs = {}

        response = await self.worker_execution_completed(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_link_workers(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "link": request.link,
        }

        response = await self.link_workers(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_controller_initiate_query_statistics(
        self, stream: grpclib.server.Stream
    ) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "filter_by_workers": request.filter_by_workers,
        }

        response = await self.controller_initiate_query_statistics(**request_kwargs)
        await stream.send_message(response)

    async def __rpc_retry_workflow(self, stream: grpclib.server.Stream) -> None:
        request = await stream.recv_message()

        request_kwargs = {
            "workers": request.workers,
        }

        response = await self.retry_workflow(**request_kwargs)
        await stream.send_message(response)

    def __mapping__(self) -> Dict[str, grpclib.const.Handler]:
        return {
            "/edu.uci.ics.amber.engine.architecture.rpc.ControllerService/RetrieveWorkflowState": grpclib.const.Handler(
                self.__rpc_retrieve_workflow_state,
                grpclib.const.Cardinality.UNARY_UNARY,
                EmptyRequest,
                RetrieveWorkflowStateResponse,
            ),
            "/edu.uci.ics.amber.engine.architecture.rpc.ControllerService/PropagateChannelMarker": grpclib.const.Handler(
                self.__rpc_propagate_channel_marker,
                grpclib.const.Cardinality.UNARY_UNARY,
                PropagateChannelMarkerRequest,
                PropagateChannelMarkerResponse,
            ),
            "/edu.uci.ics.amber.engine.architecture.rpc.ControllerService/TakeGlobalCheckpoint": grpclib.const.Handler(
                self.__rpc_take_global_checkpoint,
                grpclib.const.Cardinality.UNARY_UNARY,
                TakeGlobalCheckpointRequest,
                TakeGlobalCheckpointResponse,
            ),
            "/edu.uci.ics.amber.engine.architecture.rpc.ControllerService/DebugCommand": grpclib.const.Handler(
                self.__rpc_debug_command,
                grpclib.const.Cardinality.UNARY_UNARY,
                DebugCommandRequest,
                EmptyReturn,
            ),
            "/edu.uci.ics.amber.engine.architecture.rpc.ControllerService/EvaluatePythonExpression": grpclib.const.Handler(
                self.__rpc_evaluate_python_expression,
                grpclib.const.Cardinality.UNARY_UNARY,
                EvaluatePythonExpressionRequest,
                EvaluatePythonExpressionResponse,
            ),
            "/edu.uci.ics.amber.engine.architecture.rpc.ControllerService/ConsoleMessageTriggered": grpclib.const.Handler(
                self.__rpc_console_message_triggered,
                grpclib.const.Cardinality.UNARY_UNARY,
                ConsoleMessageTriggeredRequest,
                EmptyReturn,
            ),
            "/edu.uci.ics.amber.engine.architecture.rpc.ControllerService/PortCompleted": grpclib.const.Handler(
                self.__rpc_port_completed,
                grpclib.const.Cardinality.UNARY_UNARY,
                PortCompletedRequest,
                EmptyReturn,
            ),
            "/edu.uci.ics.amber.engine.architecture.rpc.ControllerService/StartWorkflow": grpclib.const.Handler(
                self.__rpc_start_workflow,
                grpclib.const.Cardinality.UNARY_UNARY,
                EmptyRequest,
                StartWorkflowResponse,
            ),
            "/edu.uci.ics.amber.engine.architecture.rpc.ControllerService/ResumeWorkflow": grpclib.const.Handler(
                self.__rpc_resume_workflow,
                grpclib.const.Cardinality.UNARY_UNARY,
                EmptyRequest,
                EmptyReturn,
            ),
            "/edu.uci.ics.amber.engine.architecture.rpc.ControllerService/PauseWorkflow": grpclib.const.Handler(
                self.__rpc_pause_workflow,
                grpclib.const.Cardinality.UNARY_UNARY,
                EmptyRequest,
                EmptyReturn,
            ),
            "/edu.uci.ics.amber.engine.architecture.rpc.ControllerService/WorkerStateUpdated": grpclib.const.Handler(
                self.__rpc_worker_state_updated,
                grpclib.const.Cardinality.UNARY_UNARY,
                WorkerStateUpdatedRequest,
                EmptyReturn,
            ),
            "/edu.uci.ics.amber.engine.architecture.rpc.ControllerService/WorkerExecutionCompleted": grpclib.const.Handler(
                self.__rpc_worker_execution_completed,
                grpclib.const.Cardinality.UNARY_UNARY,
                EmptyRequest,
                EmptyReturn,
            ),
            "/edu.uci.ics.amber.engine.architecture.rpc.ControllerService/LinkWorkers": grpclib.const.Handler(
                self.__rpc_link_workers,
                grpclib.const.Cardinality.UNARY_UNARY,
                LinkWorkersRequest,
                EmptyReturn,
            ),
            "/edu.uci.ics.amber.engine.architecture.rpc.ControllerService/ControllerInitiateQueryStatistics": grpclib.const.Handler(
                self.__rpc_controller_initiate_query_statistics,
                grpclib.const.Cardinality.UNARY_UNARY,
                QueryStatisticsRequest,
                EmptyReturn,
            ),
            "/edu.uci.ics.amber.engine.architecture.rpc.ControllerService/RetryWorkflow": grpclib.const.Handler(
                self.__rpc_retry_workflow,
                grpclib.const.Cardinality.UNARY_UNARY,
                RetryWorkflowRequest,
                EmptyReturn,
            ),
        }


from .. import sendsemantics as _sendsemantics__
from .. import worker as _worker__
from ... import common as __common__
import betterproto.lib.google.protobuf as betterproto_lib_google_protobuf
