# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: scalapb/scalapb.proto
# plugin: python-betterproto
# This file has been @generated

from dataclasses import dataclass
from typing import (
    Dict,
    List,
)

import betterproto
import betterproto.lib.google.protobuf as betterproto_lib_google_protobuf


class MatchType(betterproto.Enum):
    CONTAINS = 0
    EXACT = 1
    PRESENCE = 2


class ScalaPbOptionsOptionsScope(betterproto.Enum):
    """
    Whether to apply the options only to this file, or for the entire package (and its subpackages)
    """

    FILE = 0
    """Apply the options for this file only (default)"""

    PACKAGE = 1
    """Apply the options for the entire package and its subpackages."""


class ScalaPbOptionsEnumValueNaming(betterproto.Enum):
    """Naming convention for generated enum values"""

    AS_IN_PROTO = 0
    CAMEL_CASE = 1


@dataclass(eq=False, repr=False)
class ScalaPbOptions(betterproto.Message):
    package_name: str = betterproto.string_field(1)
    """If set then it overrides the java_package and package."""

    flat_package: bool = betterproto.bool_field(2)
    """
    If true, the compiler does not append the proto base file name
     into the generated package name. If false (the default), the
     generated scala package name is the package_name.basename where
     basename is the proto file name without the .proto extension.
    """

    import_: List[str] = betterproto.string_field(3)
    """
    Adds the following imports at the top of the file (this is meant
     to provide implicit TypeMappers)
    """

    preamble: List[str] = betterproto.string_field(4)
    """
    Text to add to the generated scala file.  This can be used only
     when single_file is true.
    """

    single_file: bool = betterproto.bool_field(5)
    """
    If true, all messages and enums (but not services) will be written
     to a single Scala file.
    """

    no_primitive_wrappers: bool = betterproto.bool_field(7)
    """
    By default, wrappers defined at
     https://github.com/google/protobuf/blob/master/src/google/protobuf/wrappers.proto,
     are mapped to an Option[T] where T is a primitive type. When this field
     is set to true, we do not perform this transformation.
    """

    primitive_wrappers: bool = betterproto.bool_field(6)
    """
    DEPRECATED. In ScalaPB <= 0.5.47, it was necessary to explicitly enable
     primitive_wrappers. This field remains here for backwards compatibility,
     but it has no effect on generated code. It is an error to set both
     `primitive_wrappers` and `no_primitive_wrappers`.
    """

    collection_type: str = betterproto.string_field(8)
    """
    Scala type to be used for repeated fields. If unspecified,
     `scala.collection.Seq` will be used.
    """

    preserve_unknown_fields: bool = betterproto.bool_field(9)
    """
    If set to true, all generated messages in this file will preserve unknown
     fields.
    """

    object_name: str = betterproto.string_field(10)
    """
    If defined, sets the name of the file-level object that would be generated. This
     object extends `GeneratedFileObject` and contains descriptors, and list of message
     and enum companions.
    """

    scope: "ScalaPbOptionsOptionsScope" = betterproto.enum_field(11)
    """Experimental: scope to apply the given options."""

    lenses: bool = betterproto.bool_field(12)
    """If true, lenses will be generated."""

    retain_source_code_info: bool = betterproto.bool_field(13)
    """
    If true, then source-code info information will be included in the
     generated code - normally the source code info is cleared out to reduce
     code size.  The source code info is useful for extracting source code
     location from the descriptors as well as comments.
    """

    map_type: str = betterproto.string_field(14)
    """
    Scala type to be used for maps. If unspecified,
     `scala.collection.immutable.Map` will be used.
    """

    no_default_values_in_constructor: bool = betterproto.bool_field(15)
    """
    If true, no default values will be generated in message constructors.
    """

    enum_value_naming: "ScalaPbOptionsEnumValueNaming" = betterproto.enum_field(16)
    enum_strip_prefix: bool = betterproto.bool_field(17)
    """
    Indicate if prefix (enum name + optional underscore) should be removed in scala code
     Strip is applied before enum value naming changes.
    """

    bytes_type: str = betterproto.string_field(21)
    """Scala type to use for bytes fields."""

    java_conversions: bool = betterproto.bool_field(23)
    """Enable java conversions for this file."""

    aux_message_options: List["ScalaPbOptionsAuxMessageOptions"] = (
        betterproto.message_field(18)
    )
    """List of message options to apply to some messages."""

    aux_field_options: List["ScalaPbOptionsAuxFieldOptions"] = (
        betterproto.message_field(19)
    )
    """List of message options to apply to some fields."""

    aux_enum_options: List["ScalaPbOptionsAuxEnumOptions"] = betterproto.message_field(
        20
    )
    """List of message options to apply to some enums."""

    aux_enum_value_options: List["ScalaPbOptionsAuxEnumValueOptions"] = (
        betterproto.message_field(22)
    )
    """List of enum value options to apply to some enum values."""

    preprocessors: List[str] = betterproto.string_field(24)
    """List of preprocessors to apply."""

    field_transformations: List["FieldTransformation"] = betterproto.message_field(25)
    ignore_all_transformations: bool = betterproto.bool_field(26)
    """
    Ignores all transformations for this file. This is meant to allow specific files to
     opt out from transformations inherited through package-scoped options.
    """

    getters: bool = betterproto.bool_field(27)
    """If true, getters will be generated."""

    test_only_no_java_conversions: bool = betterproto.bool_field(999)
    """
    For use in tests only. Inhibit Java conversions even when when generator parameters
     request for it.
    """


@dataclass(eq=False, repr=False)
class ScalaPbOptionsAuxMessageOptions(betterproto.Message):
    """
    AuxMessageOptions enables you to set message-level options through package-scoped options.
     This is useful when you can't add a dependency on scalapb.proto from the proto file that
     defines the message.
    """

    target: str = betterproto.string_field(1)
    """The fully-qualified name of the message in the proto name space."""

    options: "MessageOptions" = betterproto.message_field(2)
    """
    Options to apply to the message. If there are any options defined on the target message
     they take precedence over the options.
    """


@dataclass(eq=False, repr=False)
class ScalaPbOptionsAuxFieldOptions(betterproto.Message):
    """
    AuxFieldOptions enables you to set field-level options through package-scoped options.
     This is useful when you can't add a dependency on scalapb.proto from the proto file that
     defines the field.
    """

    target: str = betterproto.string_field(1)
    """The fully-qualified name of the field in the proto name space."""

    options: "FieldOptions" = betterproto.message_field(2)
    """
    Options to apply to the field. If there are any options defined on the target message
     they take precedence over the options.
    """


@dataclass(eq=False, repr=False)
class ScalaPbOptionsAuxEnumOptions(betterproto.Message):
    """
    AuxEnumOptions enables you to set enum-level options through package-scoped options.
     This is useful when you can't add a dependency on scalapb.proto from the proto file that
     defines the enum.
    """

    target: str = betterproto.string_field(1)
    """The fully-qualified name of the enum in the proto name space."""

    options: "EnumOptions" = betterproto.message_field(2)
    """
    Options to apply to the enum. If there are any options defined on the target enum
     they take precedence over the options.
    """


@dataclass(eq=False, repr=False)
class ScalaPbOptionsAuxEnumValueOptions(betterproto.Message):
    """
    AuxEnumValueOptions enables you to set enum value level options through package-scoped
     options.  This is useful when you can't add a dependency on scalapb.proto from the proto
     file that defines the enum.
    """

    target: str = betterproto.string_field(1)
    """The fully-qualified name of the enum value in the proto name space."""

    options: "EnumValueOptions" = betterproto.message_field(2)
    """
    Options to apply to the enum value. If there are any options defined on
     the target enum value they take precedence over the options.
    """


@dataclass(eq=False, repr=False)
class MessageOptions(betterproto.Message):
    extends: List[str] = betterproto.string_field(1)
    """Additional classes and traits to mix in to the case class."""

    companion_extends: List[str] = betterproto.string_field(2)
    """Additional classes and traits to mix in to the companion object."""

    annotations: List[str] = betterproto.string_field(3)
    """Custom annotations to add to the generated case class."""

    type: str = betterproto.string_field(4)
    """
    All instances of this message will be converted to this type. An implicit TypeMapper
     must be present.
    """

    companion_annotations: List[str] = betterproto.string_field(5)
    """
    Custom annotations to add to the companion object of the generated class.
    """

    sealed_oneof_extends: List[str] = betterproto.string_field(6)
    """
    Additional classes and traits to mix in to generated sealed_oneof base trait.
    """

    no_box: bool = betterproto.bool_field(7)
    """
    If true, when this message is used as an optional field, do not wrap it in an `Option`.
     This is equivalent of setting `(field).no_box` to true on each field with the message type.
    """

    unknown_fields_annotations: List[str] = betterproto.string_field(8)
    """
    Custom annotations to add to the generated `unknownFields` case class field.
    """


@dataclass(eq=False, repr=False)
class Collection(betterproto.Message):
    """
    Represents a custom Collection type in Scala. This allows ScalaPB to integrate with
     collection types that are different enough from the ones in the standard library.
    """

    type: str = betterproto.string_field(1)
    """Type of the collection"""

    non_empty: bool = betterproto.bool_field(2)
    """
    Set to true if this collection type is not allowed to be empty, for example
     cats.data.NonEmptyList.  When true, ScalaPB will not generate `clearX` for the repeated
     field and not provide a default argument in the constructor.
    """

    adapter: str = betterproto.string_field(3)
    """
    An Adapter is a Scala object available at runtime that provides certain static methods
     that can operate on this collection type.
    """


@dataclass(eq=False, repr=False)
class FieldOptions(betterproto.Message):
    type: str = betterproto.string_field(1)
    scala_name: str = betterproto.string_field(2)
    collection_type: str = betterproto.string_field(3)
    """
    Can be specified only if this field is repeated. If unspecified,
     it falls back to the file option named `collection_type`, which defaults
     to `scala.collection.Seq`.
    """

    collection: "Collection" = betterproto.message_field(8)
    key_type: str = betterproto.string_field(4)
    """
    If the field is a map, you can specify custom Scala types for the key
     or value.
    """

    value_type: str = betterproto.string_field(5)
    annotations: List[str] = betterproto.string_field(6)
    """Custom annotations to add to the field."""

    map_type: str = betterproto.string_field(7)
    """
    Can be specified only if this field is a map. If unspecified,
     it falls back to the file option named `map_type` which defaults to
     `scala.collection.immutable.Map`
    """

    no_box: bool = betterproto.bool_field(30)
    """
    Do not box this value in Option[T]. If set, this overrides MessageOptions.no_box
    """

    required: bool = betterproto.bool_field(31)
    """
    Like no_box it does not box a value in Option[T], but also fails parsing when a value
     is not provided. This enables to emulate required fields in proto3.
    """


@dataclass(eq=False, repr=False)
class EnumOptions(betterproto.Message):
    extends: List[str] = betterproto.string_field(1)
    """Additional classes and traits to mix in to the base trait"""

    companion_extends: List[str] = betterproto.string_field(2)
    """Additional classes and traits to mix in to the companion object."""

    type: str = betterproto.string_field(3)
    """
    All instances of this enum will be converted to this type. An implicit TypeMapper
     must be present.
    """

    base_annotations: List[str] = betterproto.string_field(4)
    """Custom annotations to add to the generated enum's base class."""

    recognized_annotations: List[str] = betterproto.string_field(5)
    """Custom annotations to add to the generated trait."""

    unrecognized_annotations: List[str] = betterproto.string_field(6)
    """Custom annotations to add to the generated Unrecognized case class."""


@dataclass(eq=False, repr=False)
class EnumValueOptions(betterproto.Message):
    extends: List[str] = betterproto.string_field(1)
    """Additional classes and traits to mix in to an individual enum value."""

    scala_name: str = betterproto.string_field(2)
    """Name in Scala to use for this enum value."""

    annotations: List[str] = betterproto.string_field(3)
    """
    Custom annotations to add to the generated case object for this enum value.
    """


@dataclass(eq=False, repr=False)
class OneofOptions(betterproto.Message):
    extends: List[str] = betterproto.string_field(1)
    """Additional traits to mix in to a oneof."""

    scala_name: str = betterproto.string_field(2)
    """Name in Scala to use for this oneof field."""


@dataclass(eq=False, repr=False)
class FieldTransformation(betterproto.Message):
    when: "betterproto_lib_google_protobuf.FieldDescriptorProto" = (
        betterproto.message_field(1)
    )
    match_type: "MatchType" = betterproto.enum_field(2)
    set: "betterproto_lib_google_protobuf.FieldOptions" = betterproto.message_field(3)


@dataclass(eq=False, repr=False)
class PreprocessorOutput(betterproto.Message):
    options_by_file: Dict[str, "ScalaPbOptions"] = betterproto.map_field(
        1, betterproto.TYPE_STRING, betterproto.TYPE_MESSAGE
    )
