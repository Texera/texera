package edu.uci.ics.textdb.textql.languageparser;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import org.apache.commons.lang3.builder.EqualsBuilder;

import edu.uci.ics.textdb.textql.planbuilder.beans.PassThroughBean;
import edu.uci.ics.textdb.web.request.beans.OperatorBean;
import edu.uci.ics.textdb.web.request.beans.OperatorLinkBean;
import edu.uci.ics.textdb.web.request.beans.ProjectionBean;

/**
 * Object Representation of a parsed "SELECT ..." statement.
 * 
 * @author Flavio Bayer
 *
 */
public class SelectStatement extends Statement {
    
    /**
     * Set to true when '*' is used as the fields to be projected, as in "SELECT * FROM ...".
     */
    public Boolean projectAll;
    
    /**
     * The { @link List } of fields to be projected if it is specified as.
     * in "SELECT a, b, c FROM ...".
     */
    public List<String> projectedFields;
    
    /**
     * Predicate used for data extraction such as keyword match in "KEYWORDMATCH(a,"word")".
     */
    public ExtractPredicate extractPredicate;

    /**
     * The identifier of a view or a table name, as in "SELECT... FROM viewName"
     * used as source of tuples.
     */
    public String fromClause;

    /**
     * The maximum number of tuples to be returned, as in "SELECT...FROM... LIMIT 5".
     */
    public Integer limitClause;

    /**
     * The number of tuples to be skipped before returning, as in "SELECT...FROM... OFFSET 5".
     */
    public Integer offsetClause;
      
    /**
     * Create a { @code CreateViewStatement } with all the parameters set to { @code null }.
     * @param id The id of this statement.
     */
    public SelectStatement() {
    	this(null, null, null, null, null, null, null);
    }

    /**
     * Create a { @code CreateViewStatement } with the given parameters.
     * @param id The id of this statement.
     * @param projectAll The id of this statement.
     * @param projectedFields The fields to be projected.
     * @param extractPredicate The predicate for data extraction.
     * @param fromClause The ID of the source view.
     * @param limitClause The value of the limit clause.
     * @param offsetClauseThe value of the offset clause.
     */
    public SelectStatement(String id, Boolean projectAll,
                          List<String> projectedFields, ExtractPredicate extractPredicate,
                          String fromClause, Integer limitClause, Integer offsetClause) {
        super(id);
        this.projectAll = projectAll;
        this.projectedFields = projectedFields;
        this.extractPredicate = extractPredicate;
        this.fromClause = fromClause;
        this.limitClause = limitClause;
        this.offsetClause = offsetClause;
    }
    
    /**
     * Return the ID to which a { @code LinkBean } should be connected in order to connect to the input 
     * of this operator when converted to beans.
     * @return The ID to be used as input of this operator by a { @code LinkBean }.
     */
    public String getInputID(){
        return this.id+"_s";
    }
    
    /**
     * Return the ID to which a { @code LinkBean } should be connected in order to connect to the output
     * of this operator when converted to beans.
     * @return The ID to be used as output of this operator by a { @code LinkBean }.
     */
    public String getOutputID(){
        return this.id;
    }
    
    /**
     * Return a list of links generated when this statement is converted to beans.
     * Beans will be generated for the links between Alias, Projection, Extraction and Source predicates.
     * @return The list of link beans generated by this statement.
     */
    public List<OperatorLinkBean> getInternalLinkBeans(){
        return Arrays.asList(
                   new OperatorLinkBean(this.id+"_p", this.id),
                   new OperatorLinkBean(this.id+"_e", this.id+"_p"),
                   new OperatorLinkBean(this.id+"_s", this.id+"_e")
               );
    }
    
    /**
     * Return a list of operators generated when this statement is converted to beans.
     * Beans will be generated for the Alias, Projection, Extraction and Source operators.
     * @return The list of operator beans generated by this statement.
     */
    public List<OperatorBean> getInternalOperatorBeans(){
        List<OperatorBean> operators = new ArrayList<>();
        // Build and append a PassThroughBean as an alias for this Statement
        operators.add(new PassThroughBean(this.id, "PassThrough"));
        // Build and append bean for Projection
        if(this.projectedFields==null){
            operators.add(new PassThroughBean(this.id+"_p", "PassThrough"));
        }else{
            ProjectionBean projectionBean = new ProjectionBean();
            projectionBean.setOperatorID(this.id+"_p");
            projectionBean.setOperatorType("Projection");
            projectionBean.setAttributes(String.join(",", this.projectedFields));
            operators.add(projectionBean);
        }
        // Build and append bean for Extraction predicate
        if(this.extractPredicate==null){
            operators.add(new PassThroughBean(this.id+"_e", "PassThrough"));
        }else{
            operators.add(this.extractPredicate.getExtractOperatorBean(this.id+"_e"));
        }
        // Build and append bean for the Source
        operators.add(new PassThroughBean(this.id+"_s", "PassThrough"));
        // return the build operators
        return operators;
    }

    /**
     * Return a list of ID of operators required by this statement (the dependencies of this Statement)
     * when converted to beans.
     * The only required view for a { @code SelectStatement } is the one in the From clause.
     * @return A list with the IDs of required Statements.
     */
    public List<String> getRequiredViews(){
        return Arrays.asList(this.fromClause);
    }      

    @Override
    public boolean equals(Object other) {
        if (other == null) { return false; }
        if (other.getClass() != this.getClass()) { return false; }
        SelectStatement selectStatement = (SelectStatement) other;
        return new EqualsBuilder()
                    .appendSuper(super.equals(selectStatement))
                    .append(projectAll, selectStatement.projectAll)
                    .append(projectedFields, selectStatement.projectedFields)
                    .append(extractPredicate, selectStatement.extractPredicate)
                    .append(fromClause, selectStatement.fromClause)
                    .append(limitClause, selectStatement.limitClause)
                    .append(offsetClause, selectStatement.offsetClause)
                    .isEquals();
    }
    
}




