package edu.uci.ics.textdb.textql.planbuilder;

import java.io.Reader;
import java.io.StringReader;
import java.util.ArrayList;
import java.util.List;
import java.util.function.Consumer;

import edu.uci.ics.textdb.common.exception.PlanGenException;
import edu.uci.ics.textdb.plangen.LogicalPlan;
import edu.uci.ics.textdb.textql.languageparser.ParseException;
import edu.uci.ics.textdb.textql.languageparser.Statement;
import edu.uci.ics.textdb.textql.languageparser.TextQLParser;
import edu.uci.ics.textdb.web.request.beans.FileSinkBean;
import edu.uci.ics.textdb.web.request.beans.OperatorBean;
import edu.uci.ics.textdb.web.request.beans.OperatorLinkBean;

/**
 * 
 * 
 * @author Flavio Bayer 
 * 
 */
public class TextQLLogicalPlanBuilder {
    private TextQLParser parser;
    private Consumer<Statement> parserStatemetnConsumer;
    private LogicalPlan generatedLogicalPlan;

    /**
     * Creates a TextQLLogicalPlanBuilder that uses the given { @code Reader } as input for the parser
     * @param inputQuery The input reader which the content will be parsed
     */
    public TextQLLogicalPlanBuilder(Reader inputQuery) {
        parser = new TextQLParser(inputQuery);
    }

    /**
     * Creates a TextQLLogicalPlanBuilder that uses the given { @code String } as input for the parser
     * @param inputQuery The input string to be used by the parser
     */
    public TextQLLogicalPlanBuilder(String inputQuery) {
        Reader inputQueryReader = new StringReader(inputQuery);
        parser = new TextQLParser(inputQueryReader);
    }
    
    /**
     * Set a { @code Consumer } to be called after each { @code Statement } is parsed
     * @param statemetnConsumer The { @code Consumer } to be called after each { @code Statement } is parsed
     */
    public void setParserStatemetnConsumer(Consumer<Statement> statemetnConsumer) {
        parserStatemetnConsumer = statemetnConsumer;
    }

    /**
     * This method put together all the information collected and create a Logical Plan. 
     * The created logical plan can be fetched by calling the { @code getLogicalPlan } method. 
     * @return A boolean to denote if the Logical Plan was created successfully.
     * @throws PlanGenException If the generated operator graph is not valid.
     * @throws ParseException If the input query is not valid.
     */
    public boolean buildLogicalPlan() throws PlanGenException, ParseException {
        /*
         * Steps for conversion from the input format to a logical plan:
         * Parse the input, the parser will a List of main statements parsed
         * (main statements means that not all generated statements are on the list, e.g. the substatement of a create view statement)
         * This program first extract these substatements
         * The program check if one statement has the ID "out"(a view named out)
         * if not just end, if so:
         *   convert the statements into beans
         *       create a map of <StatementId, Statement>
         *       run a BFS starting from the 'out' view
         *           append operator beans generated by Statement(an operator might create multiple beans)
         *           append link beans generated by Statement
         *           get list of dependency(other views required)
         *               if the name of the dependency is a statement
         *                   add a link going from one 
         *               if not, treat the dependency as a table/directory(?)
         *                   if there's no bean already for the scan table
         *                       create a bean to scan the the table
         *                   add link from the bean to the operator bean
         *   manually add beans for a FileSink
         *   simplify the beans:
         *       remove the pass through bean
         *       merge source and extract
         *   create logical plan
         *       append operator beans
         *       append link beans
         *   return the logical plan
         * 
         * TODO: implement Limit/offset
         * TODO: implement a proper Sink 
         * TODO: fetch schema and check if required fields are present
         * TODO: get a proper rootStatementId
         * TODO: how about the order of statements? is "SELECT * FROM v; CREATE VIEW v ..." valid?
         */
        
        // Parse input and print statements as they are parsed
        List<Statement> parsedStatements = parser.mainStatementList(parserStatemetnConsumer);
        // If there are no parsed statements then there's no plan to generate
        if (parsedStatements.size()==0){
            return false;
        }
        // Set the statement that is going to be the root of the plan, for not it is getting the last statement
        String rootStatementId = "out"; //parsedStatements.get(parsedStatements.size()-1).id;
        // Extract subStatements to the main list of statements
        TextQLLogicalPlanBuilderUtils.extractSubStatements(parsedStatements);
        // Make sure the root statement exist
        if (parsedStatements.stream().anyMatch(s -> s.id.equals(rootStatementId)) == false) {
            return false;
        }
        // Bean containers
        ArrayList<OperatorBean> operatorBeans = new ArrayList<>();
        ArrayList<OperatorLinkBean> linkBeans = new ArrayList<>();
        // convert the statements into beans, that's the first step to create a basic logical plan
        TextQLLogicalPlanBuilderUtils.statementListToBeans(parsedStatements, "out", operatorBeans, linkBeans);
        // add FileSink using the view 'out' as input(so we can generate the results)
        // TODO: The parser doesn't support Sink Operators at the moment, so a FileSink is used for now
        operatorBeans.add(new FileSinkBean("_OutputSink", "FileSink", "", null, null, "output.txt"));
        linkBeans.add(new OperatorLinkBean(rootStatementId, "_OutputSink"));
        // apply some basic simplifications to the graph
        TextQLLogicalPlanBuilderUtils.removePassThoughBeans(operatorBeans, linkBeans);
        TextQLLogicalPlanBuilderUtils.mergeSourceAndExtractBeans(operatorBeans, linkBeans);
        // Create the logical LogicalPlan: add operators, links and build
        
        generatedLogicalPlan = TextQLLogicalPlanBuilderUtils.createLogicalPlanFromBeans(operatorBeans, linkBeans);
        // if no exception is thrown then the query plan was generated successfully
        return true;
    }
    
    /**
     * Return the Logical Plan created when { @code createLogicalPlan } was called.
     * @return the created LogicalPlan.
     */
    public LogicalPlan getLogicalPlan() {
        return generatedLogicalPlan;
    }    
    
}
