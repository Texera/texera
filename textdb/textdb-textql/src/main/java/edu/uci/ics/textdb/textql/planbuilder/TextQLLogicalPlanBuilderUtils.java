package edu.uci.ics.textdb.textql.planbuilder;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.HashSet;
import java.util.LinkedList;
import java.util.List;
import java.util.ListIterator;
import java.util.Map;
import java.util.Queue;
import java.util.Set;
import java.util.function.BiFunction;
import java.util.stream.Collectors;

import edu.uci.ics.textdb.common.exception.PlanGenException;
import edu.uci.ics.textdb.plangen.LogicalPlan;
import edu.uci.ics.textdb.textql.languageparser.CreateViewStatement;
import edu.uci.ics.textdb.textql.languageparser.Statement;
import edu.uci.ics.textdb.textql.planbuilder.beans.PassThroughBean;
import edu.uci.ics.textdb.textql.planbuilder.beans.ScanSourceBean;
import edu.uci.ics.textdb.web.request.beans.KeywordMatcherBean;
import edu.uci.ics.textdb.web.request.beans.KeywordSourceBean;
import edu.uci.ics.textdb.web.request.beans.OperatorBean;
import edu.uci.ics.textdb.web.request.beans.OperatorLinkBean;

/**
 * 
 * 
 * @author Flavio Bayer 
 * 
 */
public class TextQLLogicalPlanBuilderUtils {
    
    private TextQLLogicalPlanBuilderUtils(){
        
    }
    
    /**
     * Extract subStatements contained in the main statement list and append it to the list.
     * Some statements such as CreateViewStatement have subStatements contained within that the parser does not
     * put on the main statement list.
     * This function add the statements to the list provided, that is, the list given as parameter is modified.
     * If a subStatement is already extracted, it will be duplicated.
     * @param parsedStatements List of statements to perform the extraction.
     * @return The list of main statements (the same as parsedStatements)
     */
    public static List<Statement> extractSubStatements(List<Statement> parsedStatements) {
        // iterate over the list of statements
        for (int i = 0; i < parsedStatements.size(); i++) {
            Statement statement = parsedStatements.get(i);
            // extract the subStatement if the current statement is a CreateViewStatement
            if (statement instanceof CreateViewStatement) {
                CreateViewStatement createViewStatement = (CreateViewStatement) statement;
                parsedStatements.add(createViewStatement.subStatement);
            }
        }
        return parsedStatements;
    }

    
    /**
     * Convert a list of statements into a list of OperatorBeans and OperatorLinkBean
     * A tree representing a possible query plan will be generated in which the initialStatementId
     * will be the root of the tree
     * @param statements The list of available statements to be converted
     * @param initialStatementId The ID of the initial statement to be converted (root)
     * @param operators List of OperatorBean generated from the conversion
     * @param links List of OperatorLinkBean generated from the conversion
     * @return If the conversion was finished successfully
     */
    public static boolean statementListToBeans(List<Statement> statements, String initialStatementId,
            List<OperatorBean> operators, List<OperatorLinkBean> links) {
        // clear the output lists, so only the generated result will be in them
        operators.clear();
        links.clear();
        // build a map from StatementId to Statement and check for duplicate IDs
        Map<String, Statement> nameVsStatement = new HashMap<>();
        for (Statement statement : statements) {
            if (nameVsStatement.put(statement.id, statement) != null) {
                return false; // return fail if there are multiple statements with same ID
            }
        }
        // Map of table(?directory) names to beans. The value is the ScanSourceBean of the Key table
        Map<String, ScanSourceBean> createdSourceBeans = new HashMap<>();
        // Execute a BFS and create the DAG
        Set<String> visitedStatements = new HashSet<>();
        Queue<String> toVisitStatements = new LinkedList<>(Arrays.asList(initialStatementId));
        while (!toVisitStatements.isEmpty()) {
            // get the name of next statement to visit
            String statementName = toVisitStatements.poll();
            // move statement from toVisit to visitedStatements
            if (visitedStatements.add(statementName) == false)
                continue; // skip if the statement is already on the visited statement list
            Statement statement = nameVsStatement.get(statementName);
            
            // add internal operators and links generated by the statement
            operators.addAll(statement.getInternalOperatorBeans());
            links.addAll(statement.getInternalLinkBeans());
            // process dependencies of the statement
            statement.getRequiredViews().forEach(dependency -> {
                if (nameVsStatement.containsKey(dependency)) {
                    // If there's a statement with the required name:
                    // add link and append it to the list of statements to visit
                    Statement requiredView = nameVsStatement.get(dependency);
                    links.add(new OperatorLinkBean(requiredView.getOutputID(), statement.getInputID()));
                    toVisitStatements.add(dependency);
                } else {
                    // No statement with the required name was found,
                    // assume it's a table name and create a ScanSourceBean for that table if it's not created yet
                    // and link it to the input of the statement
                    if (!createdSourceBeans.containsKey(dependency)) {
                        ScanSourceBean scanSourceBean = new ScanSourceBean(dependency, "ScanSource", "", null, null, dependency);
                        createdSourceBeans.put(dependency, scanSourceBean);
                        operators.add(scanSourceBean);
                    }
                    links.add(new OperatorLinkBean(dependency, statement.getInputID()));
                }
            });
        }
        //everything converted successfully!
        return true;
    }
    

    /**
     * Simplify the graph by removing passthrough operators from the operator list and changing the links accordingly
     * E.g. the following subgraph:
     *      ... OperatorBean0 <- PassThroughBean <- OperatorBean1 ...
     *   Will be simplified to 
     *      ... OperatorBean0 <- OperatorBean1 ...
     * The input arity of the passthrough operator must always be 1,
     * The output arity of the passthrough operator may any number grater than 1
     * 
     * @param operators List of OperatorBean generated from the conversion
     * @param links List of OperatorLinkBean generated from the conversion
     * @return If the simplification was finished successfully
     */
    public static boolean removePassThoughBeans(List<OperatorBean> operators, List<OperatorLinkBean> links) {
        // Iterate over the list of operators looking for a PassThroughBean
        for (ListIterator<OperatorBean> operatorsIt = operators.listIterator(); operatorsIt.hasNext();) {
            OperatorBean operator = operatorsIt.next();
            if (operator instanceof PassThroughBean) {
                /*
                 *  found a PassThroughBean!
                 *  look for the links coming into it (linkIn) and
                 *  look for the link going out of it (linkOut), currently limited to one at maximum
                 *  here is the subgraph we are looking right now:
                 *  
                 *      ... OperatorBean0 <- PassThroughBean <- OperatorBean1 ...
                 *                         ^ (linkOut)        ^ (linkIn)
                 *                         
                 *  move the source of the linkOut to the source of the operator bean (skip this bean), we get
                 *  
                 *                     v (linkIn)
                 *                     v---- OperatorBean1 ...
                 *      ... OperatorBean0 <- PassThroughBean 
                 *                         ^ (linkOut)  
                 *                         
                 *  discard linkIn and the operator bean
                 *  
                 *      ... OperatorBean0 <- OperatorBean1 ...
                 *                         ^ (linkIn)  
                 *                         
                 *  just like removing an item in the middle of a linked list
                 */
                for (ListIterator<OperatorLinkBean> linkInIt = links.listIterator(); linkInIt.hasNext();) {
                    OperatorLinkBean linkIn = linkInIt.next();
                    if (!linkIn.getToOperatorID().equals(operator.getOperatorID()))
                        continue; //ignore if the link does not go to the current PassThroughBean
                    for (ListIterator<OperatorLinkBean> linkOutIt = links.listIterator(); linkOutIt.hasNext();) {
                        OperatorLinkBean linkOut = linkOutIt.next();
                        if (!linkOut.getFromOperatorID().equals(operator.getOperatorID()))
                            continue; //ignore if the link does not come from the current PassThroughBean
                        // for each output link, move the source of the link to the source of the PassThroughBean
                        linkOut.setFromOperatorID(linkIn.getFromOperatorID());
                    }
                    // remove the link going into the PassThroughBean
                    linkInIt.remove();
                }
                // remove the PassThroughBean
                operatorsIt.remove();
            }
        }
        // everything converted successfully!
        return true;
    }


    /**
     * Simplify and optimize the graph by merging stream matcher operators (such as keyword matcher) with scan source 
     * operators and generating the equivalent source operator
     * E.g. the following subgraph:
     *      ... KeywordMatcherBean <- ScanSourceBean 
     *   Will be simplified to 
     *      ... KeywordSourceBean 
     * 
     * @param operators List of OperatorBean generated from the conversion
     * @param links List of OperatorLinkBean generated from the conversion
     * @return If the simplification was finished successfully
     */
    public static boolean mergeSourceAndExtractBeans(List<OperatorBean> operators, List<OperatorLinkBean> links) {
        // create a map of <operator type, merger function>, where the merger function takes one OperatorBean and
        // one ScanSourceBean, merge them and return the generated OperatorBean
        Map<String, BiFunction<OperatorBean, ScanSourceBean, OperatorBean>> matcherBeanToSourceBean;
        matcherBeanToSourceBean = new HashMap<String, BiFunction<OperatorBean, ScanSourceBean, OperatorBean>>();
        // TODO: add more operators in the future: dictionary, fuzzy token, regex, ...
        matcherBeanToSourceBean.put("KeywordMatcher", (matcherBean, scanSourceBean) -> {
            // Converter from KeywordMatcherBean+ScanSourceBean to KeywordSourceBean
            KeywordMatcherBean keywordMatcherBean = (KeywordMatcherBean)matcherBean;
            return new KeywordSourceBean(keywordMatcherBean.getOperatorID(), "KeywordSource", 
                    keywordMatcherBean.getAttributes(), keywordMatcherBean.getLimit(),
                    keywordMatcherBean.getOffset(), keywordMatcherBean.getKeyword(),
                    keywordMatcherBean.getMatchingType(), scanSourceBean.getDataSource());
            }
        );
        // The operators will be iterated and they should not be modified during this iteration, thus, a list of 
        // operators to add and remove is used to apply the changes after the iteration is over
        List<OperatorBean> operatorsToRemove = new ArrayList<>();
        List<OperatorBean> operatorsToAdd = new ArrayList<>();
        // iterate over the operator list and look for an operator which has type that can be converted
        for (OperatorBean operator : operators) {
            if (matcherBeanToSourceBean.containsKey(operator.getOperatorType())) {
                // found a matcher bean that might be converted
                // look for the link that connects to the input of the matcher bean
                OperatorLinkBean operatorInputLink = links.stream()
                                                          .filter(t -> t.getToOperatorID().equals(operator.getOperatorID()) )
                                                          .findAny()
                                                          .orElse(null);
                // look for the operator bean that is used as the input for the matcher operator
                OperatorBean operatorInput = operators.stream()
                                                      .filter(t -> t.getOperatorID().equals(operatorInputLink.getFromOperatorID()) )
                                                      .findAny()
                                                      .orElse(null);
                if (operatorInput.getOperatorType().equals("ScanSource")) {// is the source the input of a matcher?
                    // create the new operator
                    OperatorBean newOperator = matcherBeanToSourceBean.get(operator.getOperatorType())
                                                                      .apply(operator, (ScanSourceBean) operatorInput);
                    // remove old operators and the link between them
                    links.remove(operatorInputLink);
                    operatorsToRemove.add(operatorInput);
                    operatorsToRemove.add(operator);
                    // add the created operator
                    operatorsToAdd.add(newOperator);
                }

            }
        }
        // apply changes to the operator list
        operators.removeAll(operatorsToRemove);
        operators.addAll(operatorsToAdd);
        // everything converted successfully!
        return true;
    }
    

    /**
     * Build a LogicalPlan from a DAG contained in a list of operator beans and link beans
     * @param operators List of OperatorBean generated from the conversion
     * @param links List of OperatorLinkBean generated from the conversion
     * @return The generated Logical Plan
     */
    public static LogicalPlan createLogicalPlanFromBeans(List<OperatorBean> operators, List<OperatorLinkBean> links) throws PlanGenException{
        // Create the logical LogicalPlan: add operators, links and build
        LogicalPlan logicalPlan = new LogicalPlan();
        for (OperatorBean operator : operators) {
            logicalPlan.addOperator(operator.getOperatorID(), operator.getOperatorType(), operator.getOperatorProperties());
        }
        for (OperatorLinkBean link : links) {
            logicalPlan.addLink(link.getFromOperatorID(), link.getToOperatorID());
        }
        // if no exception is thrown then the query plan was generated successfully
        return logicalPlan;
    }
    


    /**
     * Convert a list of operator beans and a list of link beans to a map containing links and operators on the format
     * {
     *     "operators": [
     *         { "operator_id": "...", "operator_type": "...", operator_properties... },
     *         ...
     *     ],
     *        "links": [
     *            { "from": "...", "to": "..." },
     *         ...
     *     ]
     * }
     * 
     * @param operatorBeans the list of operator beans
     * @param linkBeans the list of link beans
     * @return The list of main statements
     */
    public static Map<String, List<Map<String, String>>> beansToMap(List<OperatorBean> operatorBeans, 
            List<OperatorLinkBean> linkBeans ) {
        // Create a list of { from, to } from the list of links
        List<Map<String, String>> links = linkBeans.stream()
                                                   .map(lb -> {
                                                        Map<String, String> link = new HashMap<String, String>();
                                                        link.put("from", lb.getFromOperatorID());
                                                        link.put("to", lb.getToOperatorID());
                                                        return link;
                                                    })
                                                   .collect(Collectors.toList());
        // Create a list of { operator_id, operator_type, other_properties } from the list of operators
        List<Map<String, String>> operators = operatorBeans.stream()
                                                    .map(ob -> {
                                                        Map<String, String> operator = new HashMap<String, String>();
                                                        operator.putAll(ob.getOperatorProperties());
                                                        operator.put("operator_id", ob.getOperatorID());
                                                        operator.put("operator_type", ob.getOperatorType());
                                                        return operator;
                                                    })
                                                    .collect(Collectors.toList());
        // Create a graph as a map of { operators, links } with the lists created earlier
        HashMap<String, List<Map<String, String>>> graph = new HashMap<String, List<Map<String, String>>>();
        graph.put("operators", operators);
        graph.put("links", links);
        return graph;
    }
    
}
