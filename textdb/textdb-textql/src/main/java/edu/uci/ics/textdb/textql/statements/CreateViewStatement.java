package edu.uci.ics.textdb.textql.statements;

import java.util.Arrays;
import java.util.Collections;
import java.util.List;

import org.apache.commons.lang3.builder.EqualsBuilder;

import edu.uci.ics.textdb.api.common.Attribute;
import edu.uci.ics.textdb.api.common.Schema;
import edu.uci.ics.textdb.api.exception.TextDBException;
import edu.uci.ics.textdb.textql.planbuilder.beans.PassThroughBean;
import edu.uci.ics.textdb.web.request.beans.OperatorBean;
import edu.uci.ics.textdb.web.request.beans.OperatorLinkBean;

/**
 * Object representation of a "CREATE VIEW ..." statement.
 * 
 * @author Flavio Bayer
 *
 */
public class CreateViewStatement extends Statement {
    
    /**
     * The statement to which the { @code CreateViewStatement } creates an alias for.
     * e.g. in "CREATE VIEW v AS SELECT * FROM t"; the view with ID 'v' will have the
     * select statement "SELECT * FROM t" as sub-statement (in a SlectExtractStatement
     * object).
     */
    private Statement subStatement;
      
    /**
     * Create a { @code CreateViewStatement } with the parameters set to { @code null }
     */
    public CreateViewStatement() {
        this(null, null);
    }
    
    /**
     * Create a { @code CreateViewStatement } with the given parameters.
     * @param id The ID of this statement.
     * @param subStatement The subStatement of this statement.
     */
    public CreateViewStatement(String id, Statement subStatement) {
        super(id);
        this.subStatement = subStatement;
    }
    
    
    /**
     * Get the sub-statement of this statement.
     * @return The sub-statement of this statement.
     */
    public Statement getSubStatement() {
        return subStatement;
    }
    
    /**
     * Set the sub-statement of the statement.
     * @param subStatement The new sub-statement to set.
     */
    public void setSubStatement(Statement subStatement) {
        this.subStatement = subStatement;
    }
    
    @Override
    public String getInputNodeID(){
        return getId();
    }

    @Override
    public String getOutputNodeID(){
        return getId();
    }
    
    /**
     * Return a list of operators generated when this statement is converted to beans.
     * The { @code CreateViewStatement } generate a { @code PassThroughBean }.
     * @return The list of operator beans generated by this statement.
     */
    @Override
    public List<OperatorBean> getInternalOperatorBeans(){
        OperatorBean passThroughOperator = new PassThroughBean(this.getId(), "PassThrough");
        return Arrays.asList(passThroughOperator);
    }
    
    /**
     * Return a list of links generated when this statement is converted to beans.
     * The { @code CreateViewStatement } generate no internal links, an empty list is returned.
     * @return The list of link beans generated by this statement.
     */
    @Override
    public List<OperatorLinkBean> getInternalLinkBeans(){
        return Collections.emptyList();
    }
     
    /**
     * Return a list of IDs of operators required by this statement (the dependencies of this Statement)
     * when converted to beans.
     * The { @code CreateViewStatement } has only its subStatement as required view.
     * @return A list with the IDs of required Statements
     */
    @Override
    public List<String> getInputViews(){
        return Arrays.asList(subStatement.getId());
    }

    /**
     * Build the resulting output schema of this predicate based on the given input schemas.
     * This statement does not apply any modification to the input schema, thus the output
     * schema is equal to the input schema.
     * The CreateViewStatement has input arity equals to 1, thus the length of the array
     * of input schemas must be 1.
     * 
     * Example: for an array containing only the following schema as input:
     *  [ { "name", FieldType.STRING }, { "age", FieldType.INTEGER }, 
     *      { "height", FieldType.HEIGHT }, { "dateOfBirth", FieldType.DATE } ]
     * The generated schema is a schema just like the input schema:
     *  [ { "name", FieldType.STRING }, { "age", FieldType.INTEGER }, 
     *      { "height", FieldType.HEIGHT }, { "dateOfBirth", FieldType.DATE } ]
     * 
     * @param inputSchemas The input schemas of this statement.
     * @return The generated output schema, a copy of the the input schema.
     * @throws TextDBException If the size of inputSchemas is different than the input arity.
     */
    @Override
    public Schema generateOutputSchema(Schema... inputSchemas) throws TextDBException {
        // Assert the input arity is one 
        if (inputSchemas.length != 1) {
            throw new TextDBException("The size of the list of input schemas must be 1");
        }
        Schema inputSchema = inputSchemas[0];
        // Return a copy of the input schema
        return new Schema(inputSchema.getAttributes().stream().toArray(Attribute[]::new));
    }
    
    
    @Override
    public boolean equals(Object obj) {
        if (obj == null) { return false; }
        if (obj.getClass() != this.getClass()) { return false; }
        CreateViewStatement otherCreateViewStatement = (CreateViewStatement) obj;
        return new EqualsBuilder()
                    .appendSuper(super.equals(otherCreateViewStatement))
                    .append(subStatement, otherCreateViewStatement.subStatement)
                    .isEquals();
    }
    
}